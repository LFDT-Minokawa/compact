# Compact reference

Compact is a strongly typed, statically typed, bounded smart contract language,
designed to be used in combination with TypeScript for writing smart contracts
for the three-part structure of Midnight, where contracts have the following
components:

- a replicated component on a public ledger
- a zero-knowledge circuit component, confidentially proving the correctness of
  the former
- a local, off-chain component that can perform arbitrary code

Each Compact program (also referred to as a *contract*) can contain several
kinds of program elements:
- module and import forms for management of namespaces and separate files,
- declarations of program-defined types,
- declarations of the data that the contract stores in the public ledger,
- declarations of `witnesses`, which are functions supplied by the TypeScript runner, and
- definitions of `circuits`, which are functions serving as the operational core of a smart contract, and
- the definition of at most one `constructor`, which is a function used to intialize the public ledger.

Compact is similar to TypeScript: it has a syntax similar to that of JavaScript,
and it layers a type system over the JavaScript syntax.
Compact deviates intentionally from TypeScript, however, in several important ways:
- Unlike TypeScript, Compact is strongly typed.
  Programs cannot bypass the static type system via missing type declarations or
  unsafe casts.
  Furthermore, the JavaScript code produced by the Compact compiler includes
  run-time checks enforcing the static types of values that come from outside
  Compact as well as preventing external application of a Compact circuit with
  more or fewer than the declared number of arguments.
- Compact provides namespace management via static rather than dynamic modules, and
  these modules can be parameterized via generic parameters, which include size as
  well as type parameters.
- Because every Compact program must compile into a set of finite proving circuits,
  all Compact types have sizes that are fixed at compile time, loops are bounded either
  by constant bounds or by the size of an object of constant size, and recursion
  is disallowed.
- Compact numeric values are limited to unsigned integers either with a
  program-declared range or with a range determined by the field size of the
  target proving system.

Like TypeScript, Compact compiles into JavaScript, but it also produces a TypeScript
definition file so that it effectively also compiles into TypeScript.
It produces separate TypeScript definition files and JavaScript implementation files
rather than simply producing TypeScript for three reasons:
- to allow compiled Compact programs to be used without requiring an additional
  TypeScript compilation step,
- to permit the generated code to check function argument counts without disabling
  argument-type checks when called from TypeScript, and
- so that it can generate a sourcemap file that properly maps elements of the
  generated JavaScript code (e.g., variable bindings and references) to the corresponding
  elements of the source Compact code.

For each circuit that touches the public ledger and hence requires a proof for
on-chain execution, the Compact compiler also produces proving circuits in a
zero-knowledge intermediate language (*zkir*), and it uses a zkir compiler to
produce proving keys for each such circuit.

Finally, the compact compiler also produces a contract info file that contains
information about the program, including version numbers and the types of the
contract's exported circuits.

This document explains each syntactic category individually.  It starts by
introducing the building blocks that are used in various contexts: identifiers,
constants, types, generic parameters, patterns, and arguments.  Then it describes
the structure of Compact programs, each kind of program element, and the
statements and expressions that can appear within circuit and constructor
definitions.
Finally, it discusses the TypeScript target.

[Writing a contract](writing-contract.html) provides a small example of what a
Compact program looks like.  It also introduces the basic building blocks of a
Compact contract.  [The full grammar of Compact](Compact.html) is provided
separately.

## Notation

The syntax of Compact programs is given by an EBNF grammar.  We use the
following notational conventions in the grammar:

- Terminals are in <b><tt>bold monospaced</tt></b> font
- Non-terminals are in <em>emphasized</em> font
- Alternation is indicated by a vertical bar (`|`)
- Optional items are indicated by a superscript <sup>opt</sup>
- Repetition is specified by ellipses. The
  notation <em>X</em> ... <em>X</em>, where <em>X</em> is a grammar symbol,
  represents zero or more occurrences of <em>X</em>. The notation <em>X</em>
  <b><tt>,</tt></b> ... <b><tt>,</tt></b> <em>X</em>, where <em>X</em> is a
  grammar symbol and <b><tt>,</tt></b> is a literal comma, represents zero or more
  occurrences of <em>X</em> separated by commas. In either case, when
  the ellipsis is marked with the superscript 1, the notation represents a
  sequence containing at least one <em>X</em>. When such a sequence is followed
  by <em>,</em><sup>opt</sup>, an optional trailing comma is allowed, but
  only if there is at least one <em>X</em>. For example, <em>id</em> &mldr;
  <em>id</em> represents zero or more <em>id</em>s, and <em>expr</em>
  <b><tt>,</tt></b> &mldr;&sup1; <b><tt>,</tt></b> <em>expr</em>
  <b><tt>,</tt></b><sup>opt</sup> represents one or more comma-separated
  <em>expr</em>s possibly followed by an extra comma.
  The rules involving commas apply equally to semicolons, i.e., apply when
  <b><tt>,</tt></b> is replaced by <b><tt>;</tt></b>.

## Static and dynamic errors

The compiler detects various kinds of *static errors*, e.g., malformed syntax,
references to undefined identifiers, and type mismatches.
When it detects one or more static errors, it prints descriptive error messages
for the errors and terminates without generating any output.

The code the compiler generates and the run-time libraries it uses detect various
kinds of *dynamic errors*, e.g., attempts from code outside of Compact to call
Compact circuits with wrong numbers or types of arguments.
These errors are reported when the generated code is run.

## Identifiers, bindings, and scope

Identifiers are used in Compact, as in most other programming languages, to
name things.
Syntactally, an *identifier* is a *token* (atomic sequence of characters), beginning
with with an alphabetic character, a dollar sign (`$`), or an underscore (`_`)
followed by one or more alphabetic characters, digits (`0` - `9`), dollar signs,
or underscores.

Some identifiers are *reserved words*.
Of these, some are used as *keywords* in the syntax of the Compact language, e.g.,
`module`, `import`, `circuit`, and `for`.
Others, specifically keywords reserved by JavaScript and TypeScript, are considered
reserved for future use in Compact, e.g., `self` and `class`.
Still others, specifically all and every identifier that begin with `__compact`,
are reserved for use by the compiler.

The remaining identifiers can be used to name specific instances of various kinds
of entities, including modules, types, generic parameters, ledger fields, function
(circuit or witness) names, function parameters, and local variables.
An identifier associated with, i.e., *bound* to, one of these entities can be
referenced anywhere within the *scope* of the binding.
Compact is lexically scoped, so the scope of each binding is limited to a specific
region of the program text.
The binding might be *shadowed* (hidden from view) in some region of program text
within its scope that contains a binding for the same identifier.

It is a static error for an identifier to be bound more than once in a same scope,
except that [function overloading](#circuit-and-witness-calls) allows
more than one function with the same name to be visible in the same scope with
different signatures, i.e., different numbers or kinds of generic parameters
and/or different numbers or types of run-time parameters.

The scope of each binding depends upon where it appears, as described below.
(The caveat "except where shadowed" is not explicitly stated but applies in each case.)
- Identifiers bound at the outermost level of a contract (refered to as the *top
  level*) are visible throughout the contract, but not within any modules that are
  imported from separate files.
- Identifiers bound at the outermost level of a module are visible throughout the module.
  They are not visible outside of the module unless exported: any exported
  binding is also visible if and where it is imported from the module.
- The generic parameters of a module, structure declaration, or function declaration
  are visible throughout the declaration.
- The run-time parameters of a circuit or constructor are visible within its body.
- Identifiers defined by a `const` binding inside a block are visible throughout
  the block.
- Identifiers defined by a `const` binding inside a `for`-loop header are
  visible throughout the `for` loop.

Every reference to an identifier must appear within the scope of a binding for
the identifier, in which case we say that the identifier is bound to the entity
associated with the identifier by that binding.
Otherwise, the reference is a static error.

For example:

```compact
circuit c(): Field {
  const answer = 42;
  {
    const answer = 12;
    assert(answer != 42, "shadowing didn't work!");
  }
  return answer; // returns 42 (the outer 'answer')
}
```

The identifier `c` is bound to the circuit named `c`, and this binding is visible
throughout the contract, though no references to `c` appear in the example.
The first (outer) binding of the identifier `answer` to the value `42` is visible
throughout the body of `c` except where shadowed by the second (inner) binding of
`answer` within in the inner block, so the reference to `answer` in `return answer`
evaluates to `42`.
The second (inner) binding of `answer` to `42` is visible throughout the inner
block, so the reference to `answer` in `answer != 42` evaluates to `12`.

## Constants

!!!!!!!! TBD

## Generic parameters and arguments

!!!!!!!! TBD

??? They have a non-empty list of comma-separated _generic parameter_ names
enclosed in angle brackets.

??? Generic arguments must be types, natural number literals, or a generic size
parameter in scope.

Generic parameters are declared in generic [module
declarations](#modules-exports-and-imports), generic [structure type
declarations](#structure-types), generic [circuit definitions](#circuits), and
generic [witness declarations](#declaring-witnesses-for-private-state).

<table className="lang-ref-table"><tbody><tr><td><em>gparams</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Generic-parameter"><em>generic-param</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Generic-parameter"><em>generic-param</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>></tt></b></td></tr>
<tr><td><em>generic-param</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>#</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>tvar-name</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#identifier"><em>tvar-name</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>gargs</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Generic-argument"><em>garg</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Generic-argument"><em>garg</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>></tt></b></td></tr>
<tr><td><em>garg</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#field-literal"><em>nat</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Type"><em>type</em></a></td></tr></tbody></table>

For generic modules, they are in scope within the module. For generic
structures, they are in scope for the structure's fields. For generic circuits,
they are in scope in the circuit's parameters, its return type annotation, and
its body. In these scopes, a reference to a generic parameter (that is not
otherwise shadowed by some other identifier binding) is either a type or a
natural-number size.

## Compact Types

Compact is *statically typed*: every expression in a Compact program must have
a static type.
For named circuits and witnesses, the parameters and return types must be explicitly
declared.
For anonymous circuit expressions, the parameters and return types do not need to
be declared but can be.
The types of `const` bindings can also be declared or not.

The language is *strongly typed*: the compiler rejects programs that do not
type check.
For example, it rejects programs in which a circuit or witness with a parameter
type annotation is called with an incorrectly typed argument for that parameter,
and it rejects programs where a circuit with a return-type annotation returns an
incorrectly typed value.
If an optional type annotation is omitted, the compiler attempts to infer a type
and it rejects the program if no such type can be inferred.

Types consist of built-in primitive types, ledger ADT types, program-defined types
defined in the program, and references to generic type parameters in scope.
When the term "type" occurs in this document without any other qualifier, it means
either a primitive type, ledger ADT type, a program-defined type, or a generic type
parameter in scope.
The use of ledger ADT types is, at present, limited to typing the result of using
`default` to obtain the default value of the type, and only constant bindings
can have a ledger ADT type.

### Primitive types

The following are the primitive types of Compact:

<table className="lang-ref-table"><tbody><tr><td><em>type</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Type-reference"><em>tref</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Boolean</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Field</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Uint</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Type-size"><em>tsize</em></a>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Uint</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Type-size"><em>tsize</em></a>&nbsp;&nbsp;<b><tt>..</tt></b>&nbsp;&nbsp;<a href="#Type-size"><em>tsize</em></a>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Bytes</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Type-size"><em>tsize</em></a>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Opaque</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#string-literal"><em>str</em></a>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Vector</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Type-size"><em>tsize</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Type"><em>type</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr>
<tr><td><em>tref</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<a href="#Generic-argument-list"><em>gargs</em></a><sup>opt</sup></td></tr>
<tr><td><em>tsize</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#field-literal"><em>nat</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr></tbody></table>

- `Boolean` is the type of *Boolean* values.  There are only two values of
  `Boolean` type.  They are the values of the expressions `true` and `false`.

- `Uint<m..n>`, where `m` is the literal `0` or generic size parameter bound
  to `0`, and where `n` is a natural number literal or a generic
  size parameter, is the type of *bounded unsigned integer* values between
  `0` (inclusive) and `n` (exclusive).
  (While the lower bound is currently required to be `0`, this restriction might
  be lifted at some point.)
  `Uint` types with different upper bounds are different types,
  although the one with the lower bound is a [subtype of the
  other](#subtyping-and-least-upper-bounds).
  In practice, there is a (large) maximum unsigned integer value determined by
  the zero-knowledge (ZK) proving system.
  Specifically, the maximum unsigned integer is `(256^k)-1` where `k` is the number
  of bytes that fits in the scalar field value of the ZK proving system.
  It is a static error whenever a `Uint` type exceeds this maximum value.

- `Uint<n>`, where `n` is a non-zero natural number literal or generic size
  parameter and bound to a non-zero natural number, is the type of
  *sized unsigned integer* values with binary representations using up to `n`
  bits.  This is the same type as `Uint<0..m>` where `m` is equal to `(2^n)-1`.
  Sized integer types can be seen as a convenience for programmers.  `Uint<32>`,
  for example, can be more obvious and less error-prone than the equivalent
  `Uint<0..4294967295>`.  Any Compact program that uses sized integer types can
  be rewritten to one that uses only bounded integer types, but the converse is
  not true.

- `Field` is the type of elements in the scalar prime field of the ZK proving system.

- `[T, ...]`, where `T, ...` are zero or more comma-separated types, is the type
  of *tuple* values with element types `T, ...`.
  Tuples are heterogeneous: any element type can differ from any of the others.
  The *length* of a tuple type is the number of element types.
  Two tuple types with different lengths are different types.
  Two tuple types where any element type of one differs from the corresponding
  element type of the other are also different types, though one of the tuple
  types might be a [subtype of the other](#subtyping-and-least-upper-bounds).

- `Vector<n, T>`, where `n` is a natural number literal or generic size
  parameter and `T` is a type, is a shorthand notation for the tuple type
  `[T, ...]` with `n` occurrences of the type `T`.
  Note that a vector type and the corresponding tuple type are two different ways
  of writing exactly the same type.
  Unless otherwise specified, type rules for vector types are derived from the
  rules for the corresponding tuple type.

- `Bytes<n>`, where `n` is a natural number literal or a generic size parameter,
  is the type of _byte array_ values of length `n`.
  `Bytes` types with different lengths are different types.
  `Bytes` types are used in the Compact standard library for hashing.
  String literals in Compact also have a `Bytes` type, where `n` is the number
  of bytes in the UTF-8 encoding of the string.

- `Opaque<s>`, where `s` is a string literal, is the type of _opaque_ values
  with tag `s`.
  The syntax of string literals in Compact is the same as in TypeScript.
  `Opaque` types with different tags are different types.
  Opaque values can be manipulated in witnesses but they are opaque to circuits.
  They are represented in circuits as their hash.
  The only tags currently allowed are `"string"` and `"Uint8Array"`.

### Program-defined types

Programs can define three kinds of new types: structures, enumerations, and
contracts.
They can also define structural and nominal aliases for existing types.

#### Structure types

Structure types are defined via a `struct` declaration with the following form:

<table className="lang-ref-table"><tbody><tr><td><em>struct</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>struct</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>struct-name</em></a>&nbsp;&nbsp;<a href="#Generic-parameter-list"><em>gparams</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Typed-identifier"><em>typed-identifier</em></a> <b><tt>;</tt></b> &mldr; <b><tt>;</tt></b> <a href="#Typed-identifier"><em>typed-identifier</em></a> <b><tt>;</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b>&nbsp;&nbsp;<b><tt>;</tt></b><sup>opt</sup></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>struct</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>struct-name</em></a>&nbsp;&nbsp;<a href="#Generic-parameter-list"><em>gparams</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Typed-identifier"><em>typed-identifier</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Typed-identifier"><em>typed-identifier</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b>&nbsp;&nbsp;<b><tt>;</tt></b><sup>opt</sup></td></tr></tbody></table>

A structure declaration has a sequence of named fields which must be separated
either by commas or by semicolons.  Comma and semicolon separators cannot be
mixed within a single structure declaration.  A trailing separator is allowed,
but not required.

Each structure field must have a type annotation.
Here are a couple of examples:

```compact
struct Thing {
  triple: Vector<3, Field>,
  flag: Boolean,
}

struct NumberAnd<T> {
  num: Uint<32>;
  item: T
}
```

The first declaration introduces a structure type named `Thing` with two fields:
`triple` (a vector with 3 field elements) and `flag` (a Boolean).
The second introduces a *generic* structure type named `NumberAnd` with generic
parameter `T` and two fields: `num` (a 32-bit unsigned integer) and `item`
(a value of type `T`).

Generic structure types are not fixed types and must eventually be *specialized*
by supplying generic arguments, e.g., `NumberAnd<Uint<8>>`.
When any generic structure type is specialized, it must be fully specialized:
the number of supplied generic arguments must match the number of declared
generic parameters.
It is possible and common for a generic structure type to be specialized via
different generic arguments in different parts of a program.

Structure typing is always `nominal`: two types are equivalent only if they
have the same names and same fields.  They are distinct if they have different
names even if they have the same fields.
More precisely:

!!!!!!!! TBD: verify

- A non-generic structure type is the same as another if they have the same name,
  same element names (in the same order), and same element types (in the same
  order).
  Otherwise they are distinct.
- The result of specializing a generic structure type is the same as a non-generic
  structure type if the specialized type has the same name, same element names,
  and same element types as the non-generic structure type.

These two rules imply that:

- Specializations of the same generic structure to the same types are the same
  type.
- Specializations of the same generic structure to different types are different
  types.

Values of structure types are created with **structure-creation** expressions.
These consist of the structure type (fully specialized if generic),
followed by a sequence of field values enclosed in curly braces (`{ }`).
Element values can be given positionally, in the same order as they are declared
in the `struct` declaration; or they can be named using the element names from
the declaration.
Named element values can appear in any order.
Positional and named element values can be mixed in the same structure creation
expression, but all the positional ones must come before any of the named ones.
See [Structure creation](#structure-creation) for the details.

Using the example declarations above, structure values could be created with
`Thing {[0, 1, 2], true}` or `NumberAnd<Uint<8>> { item: 255, num: 0 }`.

Structure types cannot be recursive, i.e., they cannot contain elements of
the same type as the structure, either directly or indirectly.
For example, it is an error to use the following pair of declarations:

!!!!!!!! TBD: is this a static error?

```compact
struct Even {
  predecessor: Odd
}

struct Odd {
  predecessor: Even
}

export circuit doesntWork(s: Even): Odd {
  return s.predecessor;
}
```

#### Enumeration types

!!!!!!!! TBD

Enumeration types are defined by a declaration beginning with the keyword
`enum`.

<table className="lang-ref-table"><tbody><tr><td><em>enumdef</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>enum</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>enum-name</em></a>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a> <b><tt>,</tt></b> &mldr;&sup1; <b><tt>,</tt></b> <a href="#identifier"><em>id</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b>&nbsp;&nbsp;<b><tt>;</tt></b><sup>opt</sup></td></tr></tbody></table>

Here is an example:

```compact
enum Fruit { apple, pear, plum }
```

An enumeration declaration introduces a named enumeration type, such as `Fruit`
in the example above.  Each enumeration declaration introduces a distinct type.

An enumeration declaration has a sequence of named values separated by commas.
A trailing separator is allowed but not required.

In the example above, the type `Fruit` has three values: `Fruit.apple`,
`Fruit.pear`, and `Fruit.plum`.

#### Contract types

As of this writing, declarations of contracts and the cross-contract calls they
support are not yet fully implemented, but the keyword `contract` used to
declare contracts is reserved for this use.

#### New types

<table className="lang-ref-table"><tbody><tr><td><em>tdefn</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>new</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>type</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>type-name</em></a>&nbsp;&nbsp;<a href="#Generic-parameter-list"><em>gparams</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr></tbody></table>

### Subtyping and least upper bounds

There is a *subtyping* relation on Compact types.  Informally, if a type `T` is
a subtype of a type `S` then every value of type `T` is also a value of type `S`
(equivalently, `S` is a supertype of `T`).  In that case, Compact allows
implicitly using a value of type `T` where a value of type `S` is expected,
without any programmer-supplied conversion.

Subtyping is defined by the following rules:

- Any type `T` is a subtype of itself (subtyping is reflexive)
- `Uint<0..n>` is a subtype of `Uint<0..m>` if `n` is less than `m`
- `Uint<0..n>` is a subtype of `Field` for all `n`
- `[T, ...]` is a subtype of `[S, ...]` if the two tuple types have the length
  and each type `T` is a subtype of the corresponding type `S`

A circuit or witness can be called with argument expressions whose types are
subtypes of the corresponding parameter type annotations.  A constant binding
statement with a type annotation can be initialized with an expression whose
type is a subtype of the type annotation.

The *least upper bound* (with respect to subtyping) of a non-empty set of types
\{`T0`, ..., `Tn`} is a type `S` such that:

- **`S` is an upper bound:** `Ti` is a subtype of `S` for all `i` in
    the range 0..`n`, and
- **`S` is the least upper bound:** for all upper bounds `R` of the set of types
    \{`T0`, ..., `Tn`}, `S` is a subtype of `R`.

Note that least upper bounds do not necessarily exist for all sets of types.

**Tuple and vector types:** We say that a tuple type `[T, ...]` with possibly
distinct types `T, ...` "*has a vector type*" if the least upper bound `S` of
the set of types \{`T`, ...} exists.  In that case, the tuple type has the
vector type `Vector<n, S>` where `n` is the length of the tuple.  Some
operations over tuples (such as mapping and folding) require the tuple type to
have a vector type.

Note that when a tuple type has a vector type, the tuple type is a subtype of
the vector type.  Perhaps surprisingly, vector types can be subtypes of tuple
types as well.  A vector type `Vector<n, T>` is a subtype of a tuple type
`[S, ...]` if the tuple has length `n` and `T` is a subtype of each of the types
`S, ...`.  The means, for instance, that a vector could be passed to a circuit
where a tuple is expected.

### Default values

Every type in Compact has a *default value* of that type.  The default values
are as follows:

- `Boolean`: the value of the literal `false`
- `Uint<0..n>` and `Uint<n>`: `0`
- `Field`: `0`
- `[T, ...]` where `T, ...` is a sequence of zero or more types: the tuple with
  the corresponding length, each of the default value of the corresponding type
- `Bytes<n>`: the byte array of length `n` with all zero bytes
- `Opaque<"string">`: an empty string, i.e., `""`
- `Opaque<"Uint8Array">`: a zero-length `Uint8Array`, i.e., `new Uint8Array(0)`
- structure types: the struct with all fields set to the default value of their
  type
- enumeration types: the first value listed in the declaration

## Parameters, patterns, and destructuring

Each parameter of a circuit or a constructor can either be a single name
(identifier) or a pattern. A pattern is a destruction of a tuple, a vector, or a
structure value. Pattern parameters can appear in [circuit
definitions](#circuits), [anonymous circuits](#circuit-and-witness-calls), and
[constructors](#contract-constructor). Patterns can also apper in [`const`
binding statements](#const-binding-statement).

<table className="lang-ref-table"><tbody><tr><td><em>typed-identifier</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a></td></tr>
<tr><td><em>simple-parameter-list</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Typed-identifier"><em>typed-identifier</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Typed-identifier"><em>typed-identifier</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr>
<tr><td><em>typed-pattern</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Pattern"><em>pattern</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a></td></tr>
<tr><td><em>pattern-parameter-list</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Typed-pattern"><em>typed-pattern</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Typed-pattern"><em>typed-pattern</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>pattern</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<a href="#Pattern"><em>pattern</em></a><sup>opt</sup> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Pattern"><em>pattern</em></a><sup>opt</sup> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Pattern-struct-element"><em>pattern-struct-elt</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Pattern-struct-element"><em>pattern-struct-elt</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b></td></tr>
<tr><td><em>pattern-tuple-elt</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;(<em>empty</em>)</td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Pattern"><em>pattern</em></a></td></tr>
<tr><td><em>pattern-struct-elt</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Pattern"><em>pattern</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>parg</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>p</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>p</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em></td></tr><tr><td><em>p</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<b>[</b>&nbsp;&nbsp;<tt>[</tt>&nbsp;&nbsp;<tt>\{</tt><b>,</b><tt>}</tt>&nbsp;&nbsp;<em>p</em>&nbsp;&nbsp;<tt>\{</tt><b>,</b><tt>}</tt>&nbsp;&nbsp;<tt>\{</tt><b>,</b>&nbsp;&nbsp;<tt>\{</tt><b>,</b><tt>}</tt>&nbsp;&nbsp;<em>p</em>&nbsp;&nbsp;<tt>\{</tt><b>,</b><tt>}</tt>&nbsp;&nbsp;<tt>}</tt>&nbsp;&nbsp;<tt>]</tt>&nbsp;&nbsp;<b>]</b></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<tt>[</tt>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<tt>[</tt><b><tt>:</tt></b>&nbsp;&nbsp;<em>p</em>]&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<b><tt>:</tt></b>&nbsp;&nbsp;<em>p</em>]}&nbsp;&nbsp;<tt>]</tt>&nbsp;&nbsp;<b><tt>}</tt></b></td></tr></tbody></table>

A *tuple pattern* destructures a tuple or a vector value and it has the form
`[id, ...]` where `id, ...` is a sequence of zero or more comma-separated
identifiers. A type annotation can be declared for a tuple pattern with the form
`[id, ...] : T` where `T` is a Compact type or a generic type parameter in
scope. It is a static type error if `T` is not a tuple or a vector type. It is a
static type error if the length of the sequence of identifiers (the number of
elements in the sequence of identifiers) is larger than the length of the tuple
or vector type. Both the sequence of identifiers and tuple type can have a
trailing comma. The sequence of identifiers can leave out some identifiers by
dropping their identifiers to skip binding some indices of the tuple, for
example, `[x, , , y] : [Boolean, Boolean, Boolean, Boolean]` binds only the
first and last element of a tuple of four boolean values. However, the tuple
type must be fully specified. The dropped identifiers count toward the length of
the tuple pattern if there exists a named identifier after the dropped ones. For
example, `[x, , , y]` matches a tuple or vector with 4 or more elements, while
`[x, y, , ]` matches a tuple or vector with 2 or more elements.

A tuple pattern has a more general form `[p, ...]` where `p, ...` is a sequence
of zero or more comma-separated patterns where a pattern can be an identifier, a
tuple pattern, or a structure pattern. Where a type annotation exists for a
tuple pattern it is a static type error if a pattern has the form of a tuple or
a structure pattern but its corresponding type annotation does not have a
tuple/vector or a structure type, respectively. For example, `[x, [y, z]] :
[Field, Boolean]` results in a static type error since the pattern `[y, z]` must
have a tuple/vector type.

A *structure pattern* desctructures a structure value and it has the form `{f,
...}` where `f, ...` is a sequence of zero or more comma-separated fields. A
type annotation can be declared for a structure pattern with the form `{f, ...}
: T` where `T` is a Compact type or a generic type parameter in scope. It is a
static type error if `T` is not a structure type. It is a static type error if
the sequence of fields contains fields that are not fields of `T`, however, the
sequence of fields does not have to bind all the fields of `T`. The sequence of
fields can contain a trailing comma, and the order of fields in the sequence `f,
...` does not have to match the order of fields in the type declaration of `T`.

A structure pattern can optionally bind a field to a new identifier by `{f: p,
...}` where `f: p, ...` is a sequence of zero or more comma-separated field `f`
bound to pattern `p`. If the pattern `p` is an identifier `x`, the value of the
field `f` is accessible via the name `x` rather than by the name `f`. It is a
static type error to bind the same identifier more than once in a scope of
destructions, for example, `{a: b, b} : S` is a static type error since `b` is
bound to both fields of the structure type, `S` is defined as `struct S {a:
Field, b: Boolean}`. If the pattern `p` is a tuple or structure desctruction it
is a static type error if the field `f` does not have a tuple or structure type,
respectively. The optional expansion to patterns can be mixed and matched with
no expansion, for example, `const {a: x, b} = S {a = 1, b = true}` is valid
given the structure definition `struct S {a: Field, b: Boolean}`. This constant
binding binds `x` to `1` and `b` to `true`.

## Programs

A compact program is a sequence of zero or more top-level program elements. The
grammar below defines the set of possible program elements:

<table className="lang-ref-table"><tbody><tr><td><em>program</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#programs"><em>pelt</em></a> &mldr; <a href="#programs"><em>pelt</em></a>&nbsp;&nbsp;<a href="#constants"><em>eof</em></a></td></tr>
<tr><td><em>pelt</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#pragmas"><em>pragma</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#include-files"><em>incld</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#modules-exports-and-imports"><em>mdefn</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#imports"><em>idecl</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#top-level-exports"><em>xdecl</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#declaring-and-maintaining-public-state"><em>ldecl</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#declaring-witnesses-for-private-state"><em>wdecl</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#contract-constructor"><em>lconstructor</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#circuits"><em>cdefn</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#structure-types"><em>struct</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#enumeration-types"><em>enumdef</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#contract-types"><em>ecdecl</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#new-types"><em>tdefn</em></a></td></tr></tbody></table>

A program element can be:

- a [pragma](#pragmas-and-versions) to declare the version of the compiler and/or the language
- an [include](#include-files) to include other Compact programs
- a [module](#modules-exports-and-imports) to define a Compact module
- an [import](#imports) to import other Compact modules
- an [export](#top-level-exports) to export top-level program elements
- a [ledger field](#declaring-and-maintaining-public-state) to declare a public state
- a [witness](#declaring-witnesses-for-private-state) to declare a private state
- a [constructor](#contract-constructor) to define the contract's constructor
- a [circuit](#circuits) to define a circuit
- a [structure type](#structure-types) to define a structure type
- an [enumeration type](#enumeration-types) to define a enumeration type
- a [contract type](#contract-types) to define a contract type
- a [type definition](#new-types) to define a new type

## Pragmas

A pragma declares a constraint on either the compiler version or the language
version. The valid identifiers for the language and compiler versions are
`language_version` and `compiler_version`, respectively.

<table className="lang-ref-table"><tbody><tr><td><em>pragma</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>pragma</tt></b>&nbsp;&nbsp;<a href="#to-be-filled-in"><em>id</em></a>&nbsp;&nbsp;<em>version-expr</em>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr>
<tr><td><em>version-expr</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<em>version-expr</em>&nbsp;&nbsp;<b><tt>||</tt></b>&nbsp;&nbsp;<em>version-expr<sub>0</sub></em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>version-expr<sub>0</sub></em></td></tr>
<tr><td><em>version-expr<sub>0</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<em>version-expr<sub>0</sub></em>&nbsp;&nbsp;<b><tt>&&</tt></b>&nbsp;&nbsp;<em>version-term</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>version-term</em></td></tr>
<tr><td><em>version-term</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<em>version-atom</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>!</tt></b>&nbsp;&nbsp;<em>version-atom</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>version-atom</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>\<=</tt></b>&nbsp;&nbsp;<em>version-atom</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>>=</tt></b>&nbsp;&nbsp;<em>version-atom</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>></tt></b>&nbsp;&nbsp;<em>version-atom</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>version-expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr>
<tr><td><em>version-atom</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#constants"><em>nat</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#constants"><em>version</em></a></td></tr></tbody></table>

## Include files

Compact supports code separation and namespaces through separate files
and modules.  The most basic of these is an `include` statement which takes a
string literal `file`.

<table className="lang-ref-table"><tbody><tr><td><em>incld</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>include</tt></b>&nbsp;&nbsp;<a href="#constants"><em>file</em></a>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr></tbody></table>

An `include "path/to/file";` statement may appear at the top level of a source
file or module. When encountered, the Compact compiler will search for a Compact
source file at `path/to/file.compact` in the current directory and then relative
to any of the directories in the `:`-separated environment variable
`COMPACT_PATH`. This file *must* be found and will be included verbatim in place
of the `include` statement.

## Modules, exports, and imports

A module is a collection of definitions whose namespace is hidden from
surrounding code.  It takes the following form:

<table className="lang-ref-table"><tbody><tr><td><em>mdefn</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>module</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>module-name</em></a>&nbsp;&nbsp;<a href="#Generic-parameter-list"><em>gparams</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Program-element"><em>pelt</em></a> &hellip; <a href="#Program-element"><em>pelt</em></a>&nbsp;&nbsp;<b><tt>}</tt></b></td></tr></tbody></table>

A module definition can optionally be exported. It must have a name.  It can
have [generic parameters](#generic-parameters) and then it has a body.  The body
contains [top-level program elements](#programs).

By default, identifiers defined within the body of a module are
visible only within the module, i.e., they are not exported from
the module.  Any identifier defined at or imported into the top
level of a module can be exported from the module in one of two
ways: (1) by prefixing the definition with the `export` keyword,
or by listing the identifier in a separate `export` declaration.
For example, the following module exports `G` and `S` but not `F`.

```compact
module M {
  export { G };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(s: S): Boolean {
    return s.y;
  }
  circuit G(s: S): Uint<16> {
    return F(s) ? s.x : 0;
  }
}
```

### Imports

A module can be imported into another definition scope, bringing
all its exported entries into that scope, potentially with a prefix.

<table className="lang-ref-table"><tbody><tr><td><em>idecl</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>import</tt></b>&nbsp;&nbsp;<a href="#Import-selection"><em>import-selection</em></a><sup>opt</sup>&nbsp;&nbsp;<a href="#Import-name"><em>import-name</em></a>&nbsp;&nbsp;<a href="#Generic-argument-list"><em>gargs</em></a><sup>opt</sup>&nbsp;&nbsp;<a href="#Import-prefix"><em>import-prefix</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr>
<tr><td><em>import-selection</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Import-element"><em>import-element</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Import-element"><em>import-element</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b>&nbsp;&nbsp;<b><tt>from</tt></b></td></tr>
<tr><td><em>import-element</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>as</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr>
<tr><td><em>import-name</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#string-literal"><em>file</em></a></td></tr>
<tr><td><em>import-prefix</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>prefix</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr></tbody></table>

For instance:

```compact
module Runner {
  export circuit run(): [] {}
}
import Runner;
// run is now in scope
import Runner prefix SomePrefix_;
// SomePrefix_run is now in scope

module Identity<T> {
  export { id }
  circuit id(x: T): T {
    return x;
  }
}
import Identity<Field>;
// id is now in scope, with Field as type T
```

Compact's standard library can be imported by `import CompactStandardLibrary`.
The standard library defines a number of useful types and circuits along with
ledger ADTs such as `Counter`, `Map`, and `MerkleTree`.

When importing module `M`, if the program does not contain a visible module definition
the compiler looks in the file system in the relative path of the current directory for `M.compact`.
In the case where a module is defined in a different program (file), the program must only contain
a top-level module definition. Otherwise, the compiler throws a static error stating that the program
does not contain a single module definition. For example, the program `M.compact` below defines
a module:

```compact title=M.compact
module M {
  export { F };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(x: S): Boolean {
    return S.y;
  }
}
// circuit cant_exists() : [] {}
// If cant_exists is uncommented, the compiler will throw an error when compiling
// test.compact
```

Then, `test.compact` imports `M`:

```compact title=test.compact
//module M {
//  export { G };
//  export struct S { x: Uint<16>, y: Boolean }
//  circuit G(x: S): Boolean {
//    return S.y;
//  }
//}
// If M is uncommented, the compiler will import this module and not the one
// defined in M.compact. In this case, the compiler will throw an error for
// exporting F.

import M;
export { F };
```

The import syntax allows the module to be identified by a string pathname. In this case, the compiler
first looks for the imported module relative to the current directory (the path of the importing
program) and then in the directories identified by `COMPACT_PATH`. Importing by a pathname allows
importing multiple modules with the same name. For example, consider the program `M.compact`:

```compact title=M.compact
module M {
  export { F };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(x: S): Boolean {
    return S.y;
  }
}
```

And the program `A/M.compact`:

```compact title=A/M.compact
module M {
  export { F };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(x: S): Boolean {
    return S.y;
  }
}
```

And finally the program `test.compact` can export both `$F` and `A_F` but not `$G`:

```compact title=test.compact
module M {
  export { G };
  export struct S { x: Uint<16>, y: Boolean }
  circuit G(x: S): Boolean {
    return S.y;
  }
}

import "M" prefix $;
// this imports M.compact and not the module M defined above

import "A/M" prefix A_;

export { $F
  ,A_F
//  ,$G
// uncommenting this will result in an error
  };
```

### Top-level exports

<table className="lang-ref-table"><tbody><tr><td><em>xdecl</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#identifier"><em>id</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b>&nbsp;&nbsp;<b><tt>;</tt></b><sup>opt</sup></td></tr></tbody></table>

The circuits exported at the top level of a contract (i.e., not merely exported
from a module) are the entry points of the contract and may not take generic
arguments. Although multiple circuits with the same name are allowed generally
to support [function overloading](#circuit-and-witness-calls), it is a static
error if more than one circuit with the same name is exported from the top
level.

Program-defined types exported from the top level of the main file can be used to
describe the argument and return types of witnesses and exported circuits; these
may accept generic arguments, but generic arguments not actually used as types
are dropped in the exported type. For example:

```compact
export struct S<#n, T> { v: Vector<n, T>; curidx: Uint<0..n> }
```

is exported for use as a TypeScript type with the `T` parameter but not the `n`
parameter, i.e.,:

```typescript
export type S<T> = { v: T[]; curidx: bigint }
```

Ledger field names exported from the top level are visible for direct inspection
by code outside of the contract via the generated TypeScript `ledger()` function.

## Declaring and maintaining public state

Compact code can declare public state through `ledger` declarations.

A ledger declaration defines one piece of information the contract
stores in Midnight's public ledger.
Multiple ledger declarations can appear in a program, or none.
They can appear anywhere circuit definitions can appear,
including within modules.

<table className="lang-ref-table"><tbody><tr><td><em>ldecl</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>sealed</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr></tbody></table>

A ledger declaration associates a ledger field name with one of a
set of predefined [ledger ADT types](#ledger-state-types)
For instance:

```compact
ledger val: Field;
export ledger cnt: Counter;
sealed ledger u8list: List<Uint<8>>;
export sealed ledger mapping: Map<Boolean, Field>;
```

### Ledger state types

In a `ledger` declaration, the following types are valid:

- `T`, for any Compact type `T`
- `Counter`
- `Set<T>`, for any Compact type `T`
- `Map<K, T>`, for any Compact types `K` and `T`
- `Map<K, V>`, for any Compact type `K` and ledger state type `V` (see the following section)
- `List<T>`, for any Compact type `T`
- `MerkleTree<n, T>`, for a compile time integer `1 < n <= 32`, and any Compact
  type `T`
- `HistoricMerkleTree<n, T>`, for a compile time integer `1 < n <= 32`, and any
  Compact type `T`

Each ledger type supports a set of operations, which can be invoked with

```compact
<field name>.<operation>(<arguments ...>)
```

A ledger field that is declared with a Compact type `T` implicitly has the type
`Cell<T>`. `Cell` has operations such as `read`, `write`, and `reset_to_default`.

The `read` and `write` operations for the `Cell` type of any Compact type `T` have syntactic
sugar. If `x` is a field in the ledger of any Compact type, then you may write

```compact
x       // expression equivalent to x.read()
x = val // statement equivalent to x.write(val)
```

The `read`, `increment`, and `decrement` operations of type `Counter` type also
have syntactic sugar.  If `c` is a `Counter` field in the ledger, then you may write

```compact
c        // expression equivalent to c.read()
c += val // statement equivalent to c.increment(val)
c -= val // statement equivalent to c.decrement(val)
```

A comprehensive list of operations can be found in
the Compact [ledger data type documentation](./ledger-adt).


### Nested state types in the `Map` type

The only ledger state type in which values of other state types may be
held is `Map`.  The key values in a `Map` must be non-state types
(simple Compact types), but the mapped values may be counters, sets,
lists, other maps, and so on.

Here is a small example:

```compact
import CompactStandardLibrary;

ledger fld: Map<Boolean, Map<Field, Counter>>;

export circuit initNestedMap(b: Boolean): [] {
  fld.insert(b, default<Map<Field, Counter>>);
}

export circuit initNestedCounter(b: Boolean, n: Field): [] {
  fld.lookup(b).insert(n, default<Counter>);
}

export circuit incrementNestedCounter(b: Boolean, n: Field, k: Uint<16>): [] {
  fld.lookup(b).lookup(n).increment(k);
}

export circuit readNestedCounter1(b: Boolean, n: Field): Uint<64> {
  return fld.lookup(b).lookup(n).read();
}

export circuit readNestedCounter2(b: Boolean, n: Field): Uint<64> {
  return fld.lookup(b).lookup(n);
}
```

In this example,
- `fld` is bound to a `Map` from `Boolean` values to `Map`s from `Field` values to `Counter`s
- `initNestedMap` can be used to create the inner `Map` for a particular outer-`Map` key
- `initNestedCounter` can be used to create a `Counter` for a given outer-`Map` key and a given inner-`Map` key
- `incrementNestedCounter` can be used to increment an existing `Counter` for a given outer-`Map` key and a given inner-`Map` key
- either `readNestedCounter1` or `readNestedCounter2` can be used to read the value of an existing `Counter`
  for a given outer-`Map` key and a given inner-`Map` key.

Notes:

1. Nesting is permitted only within `Map` values.  That is, nesting is not permitted in
   `Map` keys or within any ledger state type other than `Map`.
2. Nested values must be initialized before first use.  The syntax `default<T>`
   is used to create default ledger state type values, just as it can be used to
   create default Compact type values.
3. Ledger state type values are not first-class objects, so when
   accessing a nested value, the entire indirection chain must be
   used.  For example, the following will result in a compiler error:
   ```compact
   export circuit incrementNestedCounter(b: Boolean, n: Field, k: Uint<16>): [] {
     fld.lookup(b); // ERROR: incomplete chain of indirects
   }
   ```
4. When the last lookup is a read of a base type one can omit the
   explicit `read()` indirect, as illustrated by the definitions of
   `readNestedCounter1` and `readNestedCounter2` above, which have the
   same behavior.
5. For convenience, local variables can hold default ledger state type values,
   so the following definition of `initNestedMap` is equivalent to the one
   above.
   ```compact
   export circuit initNestedMap(b: Boolean): [] {
     const t = default<Map<Field, Counter>>;
     fld.insert(b, t);
   }
   ```

### Sealed and unsealed ledger fields

Any ledger field can be optionally marked *sealed* by prefixing the
ledger field declaration with the keyword `sealed`.  A sealed field
cannot be set except during contract initialization.  That is, its
value can be modified only by the contract constructor (if any),
either directly within the body of the constructor or via helper
circuits called by the constructor. The `sealed` keyword must come after
the `export` keyword (if present) and before the `ledger` keyword, as
in the following example:

```compact
sealed ledger field1: Uint<32>;
export sealed ledger field2: Uint<32>;

circuit init(x: Uint<32>): [] {
  field2 = x;
}

constructor(x: Uint<16>) {
  field1 = 2 * x;
  init(x);
}
```

It is a static error if a sealed ledger field can be set by any
code that is reachable from an exported circuit.

## Declaring witnesses for private state

Compact code can call code external to the zero-knowledge circuits to read
and update private state via `witness` functions.

A `witness` function declaration can appear anywhere a `circuit`
definition can appear, including within modules.  A witness function does not
have a body, and its implementation is instead an input to
the contract in the TypeScript target.

<table className="lang-ref-table"><tbody><tr><td><em>wdecl</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>witness</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<a href="#Generic-parameter-list"><em>gparams</em></a><sup>opt</sup>&nbsp;&nbsp;<a href="#Simple-parameter-list"><em>simple-parameter-list</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr></tbody></table>

For instance:

```compact
witness something(x: Boolean): Field;
```

A `witness` function can be called in the same way as a `circuit`.

:::danger

Do not assume in your contract that the code of any `witness` function
is the code that you wrote in your own implementation.  Any DApp may
provide any implementation that it wants for your `witness` functions.
Results from them should be treated as untrusted input.

:::

## Contract constructor

A contract can be initialized via a contract constructor defined at the
program's top level.
The constructor, if any, is typically used to initialize public state
and can also be used to initialize private state through witness
calls.

<table className="lang-ref-table"><tbody><tr><td><em>lconstructor</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>constructor</tt></b>&nbsp;&nbsp;<a href="#Pattern-parameter-list"><em>pattern-parameter-list</em></a>&nbsp;&nbsp;<a href="#Block"><em>block</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>prog</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>constructor</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>p</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>p</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em>}]&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<em>block</em>&nbsp;&nbsp;</td></tr></tbody></table>

A constructor has the form `constructor (p: T, ...) block` where `p: T, ...` is a sequence of zero or more comma-separated
[parameter declarations with type annotations](#parameters-patterns-and-destructuring)
and `block` is a sequence of zero or more semicolon-delimited statements
enclosed in curly braces (`{ }`). The return type of a constructor is `[]`.

At most one contract constructor can be defined for a contract, and it
must appear only at the program top level, i.e., it cannot be defined in
a module.
To initialize ledger fields that are visible only within a module, the
constructor can call a circuit that is exported from the module.
For example:

```compact
module PublicState {
  enum STATE { unset, set }
  ledger state: STATE;
  ledger value: Field;
  export circuit init(v: Field): [] {
    value = disclose(v);
    state = STATE.set;
  }
}

import PublicState;

constructor(v: Field) {
  init(v);
}
```

## Circuits
The basic operational element in Compact is the `circuit`. This corresponds
closely to a function in most languages but is compiled directly into a
zero-knowledge circuit.

<table className="lang-ref-table"><tbody><tr><td><em>cdefn</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>export</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>pure</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>circuit</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>function-name</em></a>&nbsp;&nbsp;<a href="#Generic-parameter-list"><em>gparams</em></a><sup>opt</sup>&nbsp;&nbsp;<a href="#Pattern-parameter-list"><em>pattern-parameter-list</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a>&nbsp;&nbsp;<a href="#Block"><em>block</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>prog</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;[<b><tt>export</tt></b>]&nbsp;&nbsp;[<b><tt>pure</tt></b>]&nbsp;&nbsp;<b><tt>circuit</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<em>gpars</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>p</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>p</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em>}]&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em>&nbsp;&nbsp;<em>block</em>&nbsp;&nbsp;</td></tr><tr><td><em>gpars</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;[<b><tt>\<</tt></b>&nbsp;&nbsp;[<em>gpar</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>gpar</em>}]&nbsp;&nbsp;<b><tt>></tt></b>]&nbsp;&nbsp;</td></tr><tr><td><em>gpar</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>#</tt></b><em>id</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>id</em></td></tr><tr><td><em>block</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<em>stmt</em>&nbsp;&nbsp;<b><tt>;</tt></b>&nbsp;&nbsp;<b><tt>}</tt></b></td></tr></tbody></table>

Circuits can optionally be exported. [They can also optionally be declared as
`pure` circuits.](#pure-and-impure-circuits) *Non-generic* circuit definitions
have the form `circuit c(p: T, ...): R block` where `c` is the name of the
circuit, `p: T, ...` is a sequence of zero or more comma-separated [parameter
declarations with type annotations](#parameters-patterns-and-destructuring), `R`
is the *return type* of the circuit: the circuit must return an expression of
type `S` where `S` is a subtype of `R`, and `block` is a sequence of zero or
more semicolon-delimited statements enclosed in curly braces (`{ }`) where each
path through the block must end with a `return` statement, unless the return
type is `[]`.

Circuits can be generic. *Generic* circuit definitions have the form `circuit
c<V, ...>(p: T, ...): R block` where `V, ...` is a sequence of zero or more
generic parameters. These generic parameters are in scope in type annotations of
parameter declarations `p: T, ...`, the return type `R`, and the circuit's
`block`. If `V` is a generic size parameter it must be prefixed with `#`,
however, when it is referenced in its [scope](#generic-parameter-references) the
`#` prefix must be dropped. It is a static type error to export generic
circuits.

### Pure and impure circuits

A Compact circuit is considered *pure* if it computes its outputs from its
inputs without reference to or modification of public state (via the ledger) or
private state (via witnesses). In practice, the compiler considers a circuit to
be impure if the body of the circuit contains a ledger operation, a call to any
impure circuit, or a call to a witness.

Some external circuits defined in `CompactStandardLibrary` are witnesses; calls
to these make the caller impure. The remainder are considered pure, so calls to
those do not make the caller impure.

A Compact program can declare a circuit to be pure by prefixing the circuit
definition with the `pure` modifier, which must follow the `export` modifier,
if present, e.g.:

```compact
pure circuit c(a: Field): Field {
  ...
}

export pure circuit c(a: Field): Field {
  ...
}
```

The only effect of the `pure` modifier is that the compiler will flag the
declaration as an error if its own analysis determines that the circuit is
actually impure. The pure modifier allows an application to ensure that the
circuit will be present in the `PureCircuits` type declaration and via the
`pureCircuits` constant in the TypeScript module produced for a (correct)
Compact program by the Compact compiler.

## Statements

<table className="lang-ref-table"><tbody><tr><td><em>block</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Statement"><em>stmt</em></a> &mldr; <a href="#Statement"><em>stmt</em></a>&nbsp;&nbsp;<b><tt>}</tt></b></td></tr>
<tr><td><em>stmt</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>if</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression-sequence"><em>expr-seq</em></a>&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<a href="#Statement"><em>stmt</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Statement0"><em>stmt<sub>0</sub></em></a></td></tr>
<tr><td><em>stmt<sub>0</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression-sequence"><em>expr-seq</em></a>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>return</tt></b>&nbsp;&nbsp;<a href="#Expression-sequence"><em>expr-seq</em></a>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>return</tt></b>&nbsp;&nbsp;<b><tt>;</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>if</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression-sequence"><em>expr-seq</em></a>&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<a href="#Statement0"><em>stmt<sub>0</sub></em></a>&nbsp;&nbsp;<b><tt>else</tt></b>&nbsp;&nbsp;<a href="#Statement"><em>stmt</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>for</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<b><tt>const</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>of</tt></b>&nbsp;&nbsp;<a href="#field-literal"><em>nat</em></a>&nbsp;&nbsp;<b><tt>..</tt></b>&nbsp;&nbsp;<a href="#field-literal"><em>nat</em></a>&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<a href="#Statement"><em>stmt</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>for</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<b><tt>const</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>of</tt></b>&nbsp;&nbsp;<a href="#Expression-sequence"><em>expr-seq</em></a>&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<a href="#Statement"><em>stmt</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>const</tt></b>&nbsp;&nbsp;<a href="#Const-Binding"><em>cbinding</em></a> <b><tt>,</tt></b> &mldr;&sup1; <b><tt>,</tt></b> <a href="#Const-Binding"><em>cbinding</em></a> &nbsp;&nbsp;<b><tt>;</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Block"><em>block</em></a></td></tr></tbody></table>

A statement may be
- a [`for` loop](#for-loop)
- an [`if` statement](#if-statement)
- a [`return` statement](#return-statement)
- a block - a sequence of zeror or more statements in a nested scope, enclosed by curly braces
- a [`const` binding statement](#const-binding-statement)
- an [expression](#expressions)

#### `for` loop

A `for` loop repeats for a fixed number of iterations, using one of the two
syntaxes below:

```compact
for (const i of <vector>) <statement>

for (const i of <lower>..<upper>) <statement>
```

#### `if` statement

An `if` statement is of one of the following forms:

```compact
if (testexpr)
  <statement>

if (testexpr)
  <statement>
else
  <statement>
```

#### `return` statement

A `return` statement can appear only in a block.

<table className="lang-ref-table"><tbody><tr><td><em>stmt</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>return</tt></b>&nbsp;&nbsp;[<em>expr</em>]<b><tt>;</tt></b></td></tr></tbody></table>

A `return` statement takes either the form `return;` or `return e;` where `e` is
a Compact expression. For a `return` statement of form `return e;` it is a
static type error if the static type of `e` is not a
[subtype](#subtyping-and-least-upper-bounds) of the declared return type `R` of
a circuit (accounting for [anonymous circuits](#circuit-and-witness-calls) and
[constructors](#contract-constructor)) if one exists. For a `return` statement
of the form `return;`, it is a static type error if the return type `R` is not
[].

If the return type `R` is `[]` the `return` statement can be dropped. However,
for return types other than `[]` it is a static type error if there exists a
path in a circuit block that does not have a `return` statement, for example,
`export circuit foo(c: Boolean): Boolean { return ((x) : Boolean => { if (c)
return x; })(c);}` causes a static type error since the `else` branch of the
`if` statements has type `[]`. It is a static type error to have a statement
after a `return` statement in a same block.

#### `const` binding statement

The syntaxt of a Compact constant binding is the same as a constant binding in
TypeScript.

<table className="lang-ref-table"><tbody><tr><td><em>optionally-typed-pattern</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Pattern"><em>pattern</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Typed-pattern"><em>typed-pattern</em></a></td></tr>
<tr><td><em>cbinding</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Optionally-typed-pattern"><em>optionally-typed-pattern</em></a>&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>stmt</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>const</tt></b>&nbsp;&nbsp;<tt>\{</tt>&nbsp;&nbsp;<em>parg</em>&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>parg</em>&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<tt>}</tt></td></tr></tbody></table>

A `const` binding brings a new identifier into scope and assigns it to the value
of an expression.

It can bring into scope a *single pattern* with `const p = e` where `p` is the
new pattern and `e` is an expression. `p` can be an identifier, a tuple pattern,
or a structure pattern:

- If `p` is an identifier the static type of the identifier is the type of `e`
  and the identifier is bound to the value of `e`.

- If `p` is a tuple pattern `e` must have a tuple or a vector type, otherwise it
  is a static type error. It is a static type error if the number of identifiers
  are more than the length of tuple `[v, ...]` where `[v, ...]` is the result of
  evaluating `e`. However, it is not a static type error if the number of
  identifiers are less than the length of `[v, ...]`, in this case identifiers
  are bound from left-to-right to elements in `[v, ...]` until there is no more
  identifiers to bind to the next elements of `[v, ...]`. The sequence of
  identifiers does not have to bind every element of a tuple, that is, it can
  drop some of the identifiers to skip binding them, for example, `const [a, ,
  b] = [1, 2, 3]` binds `1` to `a` and `3` to `b`. These skipped identifiers are
  counted towards the length of the sequence of identifiers. For example, `[a, ,
  b]` matches a tuple or vector with three or more elements.

- If `p` is a structure pattern, `e` must have a structure type, otherwise it is
  a static type error. The fields of pattern `p` must be a subset of the
  structure type's fields, otherwise it is a static type error. The order of
  fields does not matter.

A `const` binding can bring into scope *multiple patterns* with `const p = e,
...` where `p = e` is a sequencce of one or more comma-separated single pattern
constant bindings. It is a static type error if the The static typing of rules
described for a single pattern binding must hold of each identifier is the type
of its assigned expression. Constant bindings are evaluate from left-to-right.
This means that an identifier can only be referenced after it is bound. It is a
static type error to bind an identifier more than once. It is a static type
error to reference an identifier before binding it.

A `const` binding can optionally declare the type for each binding with `const
p: T = e`. It is a static type error if `e` does not have type `T`. In `const`
statements with multiple pattern/expression pairs, it is permissible to for some
of the pairs to include types and some not to include types, that is, a binding
such as `const x: Field = 2, y = true` is valid.

Any identifier bound by `const` may not be reused within a block, and
identifiers cannot be reassigned, although they can be [shadowed in a nested
block](#scope-and-binding). Constant initializer expressions are evaluated when
the binding statement is executed.

## Expressions

This section describes the syntax of Compact expressions, in order with those
of lower precedence preceding those with lower precedence, and provides their
static typing rules and evaluation semantics.

Every Compact expression is required to be well-typed (free from static type errors).
If any expression within a program contains a type error, the Compact compiler
reports the error and does not produce any target code (TypeScript or Zkir)
for the program.
The static type of a well-typed expression is either a Compact type or a ledger
state type.

Every Compact expression either evaluates to a value or raises an
exception.  The evaluation of an expression is defined in terms of the
evaluation of its subexpressions.  If the evaluation of a subexpression raises
an exception, then the evaluation of the containing expression will stop and
raise the same exception.

### Sequence expressions

Expressions can be sequenced for their side effects.  An expression of the form
`(e0, e1, e2, ...)` or `e0, e1, e2, ...` where `e0, e1, e2, ...` is a sequence of two or more
comma-separated expressions is a sequence expression. The latter form where parentheses can
be omitted is only allowed in some context which can be viewed in
[the formal grammar of Compact](./compact-grammar).

<table className="lang-ref-table"><tbody><tr><td><em>expr-seq</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b> &mldr;&sup1; <b><tt>,</tt></b> <a href="#Expression"><em>expr</em></a> &nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;</td></tr></tbody></table>

The static type of a sequence expression is the static type of the last
subexpression.

It is evaluated by evaluating the subexpressions from left to right.  Its value
is the value of the last subexpression.

### Conditional expressions and ledger assignment expressions

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression0"><em>expr<sub>0</sub></em></a>&nbsp;&nbsp;<b><tt>?</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression0"><em>expr<sub>0</sub></em></a>&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression0"><em>expr<sub>0</sub></em></a>&nbsp;&nbsp;<b><tt>+=</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression0"><em>expr<sub>0</sub></em></a>&nbsp;&nbsp;<b><tt>-=</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression0"><em>expr<sub>0</sub></em></a></td></tr></tbody></table>

#### Conditional expressions

Compact supports conditional expressions of the form `e0 ? e1 : e2` where `e0`,
`e1`, and `e2` are expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>?</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Conditional expressions require the type of `e0` to be `Boolean`.  The types of
`e1` and `e2` must be in the subtype relation.  That is, either the type of
`e1` is a subtype of the type of `e2` or else the type of `e2` is a subtype of
the type of `e1`.

The type of the entire expression is the type of `e2` if `e1` is a subtype of
`e2` and the type of `e1` if `e2` is a subtype of `e1`.

Conditional expressions are evaluated by first evaluating `e0`.  Then, the
value of that expression determines which of the other subexpressions is
evaluated:

- if the value of `e0` is `true`, then `e1` is evaluated and its value is the
  value of the entire expression
- if the value of `e0` is `false`, then `e2` is evaluated and its value is the
  value of the entire expression

The evaluation rules ensure that only one of `e1` and `e2` is evaluated.

#### Ledger assignment expressions

Compact has ledger assignment statements.  They have the form `lhs op e` where
`lhs` is a ledger expression as defined in the section **Ledger expressions**
above, `op` is one of the assignment operators `=` (assignment), `+=` (addition
assignment), or `-=` (subtraction assignment), and `e` is an expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>+=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>-=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

`lhs = e` is shorthand for `lhs.write(e)`.  `lhs += e` is shorthand for
`lhs.increment(e)`.  `lhs -= e` is shorthand for `lhs.decrement(e)`.

Ledger assignment statements are type checked exactly as if they were their
longer equivalent invoking a ledger ADT operation.

They are evaluated exactly as if their longer equivalent were evaluated as a
ledger expression.

### Short-circuit logical expressions

Compact supports short-circuit logical expressions of the form `e0 op e1`
where `e0` and `e1` are expressions and `op` is one of the logical operators
**or** (`||`) or **and** (`&&`).

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>0</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression0"><em>expr<sub>0</sub></em></a>&nbsp;&nbsp;<b><tt>||</tt></b>&nbsp;&nbsp;<a href="#Expression1"><em>expr<sub>1</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression1"><em>expr<sub>1</sub></em></a></td></tr>
<tr><td><em>expr<sub>1</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression1"><em>expr<sub>1</sub></em></a>&nbsp;&nbsp;<b><tt>&&</tt></b>&nbsp;&nbsp;<a href="#Expression2"><em>expr<sub>2</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression2"><em>expr<sub>2</sub></em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>||</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&amp;&amp;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Logical expressions require the type of the left subexpression to be `Boolean`.
The type of the right subexpression must be a supertype of `Boolean`.  The only
supertype of `Boolean` is `Boolean` itself.  The entire expression will have the
same type as the type of the right subexpression.

Logical expressions are evaluated by first evaluating the left subexpression.
Then, the value of that expression determines the value of the entire
expression as follows:

- For or, if the value of the left subexpression is `false` then the right
  subexpression is evaluated and its value is the value of the entire
  expression.  Otherwise, the right subexpression is *not* evaluated and the
  value of the left subexpression, implicitly cast to the type of the entire
  expression, is the value of the entire expression.
- For and, if the left subexpression is `true` then the right subexpression is
  evaluated and its value is the value of the entire expression.  Otherwise,
  the right subexpression is *not* evaluated and the value of the left
  subexpression, implicitly cast to the type of the entire expression, is the
  value of the entire expression.

### Relational comparison expressions

Relational comparison expressions are of the form `e0 op e1` where `e0`
and `e1` are expressions and `op` is one of Compact's relational operators.
The relational operators are **equals** (`==`), **not equals** (`!=`), **less
than** (`<`), **greater than** (`>`), **less than or equals** (`<=`), and
**greater than or equals** (`>=`).

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>2</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression2"><em>expr<sub>2</sub></em></a>&nbsp;&nbsp;<b><tt>==</tt></b>&nbsp;&nbsp;<a href="#Expression3"><em>expr<sub>3</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression2"><em>expr<sub>2</sub></em></a>&nbsp;&nbsp;<b><tt>!=</tt></b>&nbsp;&nbsp;<a href="#Expression3"><em>expr<sub>3</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression3"><em>expr<sub>3</sub></em></a></td></tr>
<tr><td><em>expr<sub>3</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a>&nbsp;&nbsp;<b><tt>\<=</tt></b>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a>&nbsp;&nbsp;<b><tt>>=</tt></b>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a>&nbsp;&nbsp;<b><tt>></tt></b>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>==</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>!=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Equals and not equals require the types of the subexpressions to be in the
subtype relation.  That is, the type of the first subexpression must be a
subtype of the type of the second subexpression, or else the type of the second
subexpression must be a subtype of the type of the first subexpression.

Less than, greater than, less than or equals, and greater than or equals require
the type of both subexpressions to be unsigned integer types (note that `Field`
cannot be compared with these operators).

The type of the result is `Boolean`.

Relational comparison expressions are evaluated by evaluating the subexpressions
in order from left to right.  Then the comparison is performed as described
below.

**Equals**

The comparison that is performed depends on the type of the operands:

- **`Boolean`:** if the operands have type `Boolean`, then the values must be
  the same boolean value.  Both operands will have type `Boolean` due to the static typing rules.
- **`Uint`:** if the operands have unsigned integer types, then the integer
  values must be equal.  Both operands will have unsigned integer types due to
  the static typing rules.
- **`Field`:** if either operand has type `Field`, then the integer values of
  the operands must be equal.  Both operands will have numeric (`Field` or
  unsigned integer) types due to the static typing rules.
- **`Bytes:`** if the operands have bytes types, then the corresponding bytes
  at each index must be equal.  Both operands will have bytes types and their
  lengths will be equal due to the static typing rules.
- **`Tuple:`** if the operands have tuple types, then the corresponding
  element values at each index must be equal according to these rules, based on
  the static element types.  Both operands will have tuple types, they will
  have the the same length, and their element types will be in the subtype
  relation due to the static typing rules.
- **`Opaque:`** if the operands have opaque types, then the runtime values
  must be equal according to JavaScript's strict equality (`===`) operator.
  Both operands will have the same opaque type due to the static typing rules.
- **structure type:** if the operands have structure types, then the
  corresponding values of each field must be equal according to these rules,
  based on the field types.  Both operands will have the same structure type due
  to the static typing rules.
- **enum type:** if the operands have enum types, then they must be the same
  enum value.  Both operands will have the same enum type due to the static
  typing rules.

**Not equals**

The operands are compared according to the rules for equals above, and then the
boolean result is negated.

**Less than, greater than, less than or equals, and greater than or equals**

The integer values of the operands are compared according to the relational
operation.  Both operands will have unsigned integer types due to the static
typing rules.

### Type cast expressions

Type cast expressions in Compact are of the form `e as T` where `e` is an
expression, `as` is a reserved words, and `T` is a Compact type.

TypeScript-style casts of the form `<T>e` are not supported in Compact.

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>4</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression4"><em>expr<sub>4</sub></em></a>&nbsp;&nbsp;<b><tt>as</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression5"><em>expr<sub>5</sub></em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>as</tt></b>&nbsp;&nbsp;<em>type</em></td></tr></tbody></table>

Type cast expressions are type checked by checking the type of the
subexpression.  If the cast from the subexpression's type to the
type `T` named in the type cast is allowed, then the static type
of the expression will be `T`.  Otherwise, it is a static type
error.

Upcasts, i.e., casts from a type to a supertype, are allowed but
never required and never result in a static or run-time error.

The table below describes the allowed type casts.  Casting between
types not shown in the table is not allowed.  The entries in the
table can be one of:

- **static:** the type cast only changes the static type and does
  not have any effect at runtime
- **conversion:** the type cast always succeeds but has the runtime
  effect of converting between different source and target
  representations, which normally has a low cost
- **checked:** the type cast is checked at runtime and can fail
- **no:** the type cast is not allowed
- a number: see the corresponding note below the table

<table>
  <thead>
    <tr>
      <th colspan="2"></th>
      <th colspan="4">TO</th>
    </tr>
    <tr>
      <th colspan="2"></th>
      <th><tt>Field</tt></th>
      <th><tt>Uint\<0..n></tt></th>
      <th><tt>Boolean</tt></th>
      <th><tt>Bytes\<n></tt></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5">FROM</th>
      <th><tt>Field</tt></th>
      <td>static</td>
      <td>checked</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th><tt>Uint\<0..m></tt></th>
      <td>static</td>
      <td>3</td>
      <td>conversion</td>
      <td>no</td>
    </tr>
    <tr>
      <th>enum type</th>
      <td>conversion</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
    <tr>
      <th><tt>Boolean</tt></th>
      <td>conversion</td>
      <td>4</td>
      <td>no</td>
      <td>no</td>
    </tr>
    <tr>
      <th><tt>Bytes\<m></tt></th>
      <td>5</td>
      <td>no</td>
      <td>no</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

1. `Field` to `Boolean`: the value `0` is converted to `false` and all other
   values are converted to `true`.
2. `Field` to `Bytes<n>`: the value of the field is converted into `Bytes` of
   the given length, with the least-significant byte of the field occurring
   first in the `Bytes`. The `Bytes` will be padded to the length with trailing
   zeros.  It is a runtime error if the field value does not fit in the length.
3. `Uint<0..m>` to `Uint<0..n>`: if `m` is less than or equal to `n` this is a
   static cast.  Otherwise it is checked and will fail at runtime if the value
   is greater than `n`.
4. `Boolean` to `Uint<0..n>`: If `n` is not 0 then this is a conversion of
   `false` to 0 and `true` to 1. Otherwise, it is checked and will fail at
   runtime if the value is `true` (and convert `false` to 0).
5. `Bytes<m>` to `Field`: the bytes are converted into a field with the
   least-significant byte of the field occurring first in the `Bytes`.  It is a
   runtime error if the result would exceed the maximum `Field` value.
6. `Bytes<m>` to `Bytes<n>`: the cast is a static cast if `m` equals `n`, and is
   not allowed otherwise.

Allowed type casts are evaluated by first evaluating the subexpression.
Then, if the cast is static, the result is the subexpression's value
interpreted as the type `T` mentioned in the cast expression.  If the
cast is a conversion, the JavaScript representation of the subexpression's
value is converted into the representation of a value of type `T`. If the
cast is checked, the check is performed before conversion and the cast
fails (at runtime) if the check fails.  The exceptions noted in the table
are evaluated as described above after evaluating the subexpression.

### Binary arithmetic expressions

Binary arithmetic expressions are of the form `e0 op e1` where `e0` and `e1`
are expressions and `op` is one of Compact's binary arithmetic operators.  The
binary arithmetic operators are **add** (`+`), **subtract** (`-`) and
**multiply** (`*`).

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>5</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression5"><em>expr<sub>5</sub></em></a>&nbsp;&nbsp;<b><tt>+</tt></b>&nbsp;&nbsp;<a href="#Expression6"><em>expr<sub>6</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression5"><em>expr<sub>5</sub></em></a>&nbsp;&nbsp;<b><tt>-</tt></b>&nbsp;&nbsp;<a href="#Expression6"><em>expr<sub>6</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression6"><em>expr<sub>6</sub></em></a></td></tr>
<tr><td><em>expr<sub>6</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression6"><em>expr<sub>6</sub></em></a>&nbsp;&nbsp;<b><tt>*</tt></b>&nbsp;&nbsp;<a href="#Expression7"><em>expr<sub>7</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression7"><em>expr<sub>7</sub></em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>+</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>-</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>*</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Arithmetic expressions require the type of both subexpressions to be numeric
types, that is, either a `Field` or a `Uint`.  The type of the result will
depend on the types of the subexpressions as follows:

- If either subexpression has type `Field`, the result will have type `Field`
- Otherwise the left subexpression will have type `Uint<0..m>` and the right
  subexpression will have type `Uint<0..n>` for some bounds `m` and `n`. The
  type of the result depends on the operation as follows:
  - For add, the result will have type `Uint<0..m+n>`
  - For subtract, the result will have type `Uint<0..m>`
  - For multiply, the result will have type `Uint<0..m*n>`

For arithmetic operations with `Uint` result types, it is a static type error if
the result's bound would be greater than the maximum unsigned integer.

Arithmetic expressions are evaluated by first evaluating the subexpressions in
order from left to right.  Integer addition, subtraction, or multiplication is
then used on the subexpression values.  The overflow and underflow behavior
differs for `Field` and `Uint` operations:

- `Field` arithmetic overflow and underflow wraps around 0; that is, the result
  of an arithmetic operation whose result is a `Field` is the actual arithmetic
  value modulo `k`, where `k` is one more than the maximum field value.
- `Uint` addition and multiplication cannot overflow: the static type of the
  result will always be large enough to hold the result value
- `Uint` subtraction checks if the value of the right subexpression is greater
  than the value of the left subexpression.  If so, it is a runtime error (the
  result would be negative).  Otherwise the unsigned subtraction is performed.

The static typing rules imply that if `Field` arithmetic semantics is desired,
then at least one of the operands must have static type `Field`.

### Boolean negation expressions

Compact has unary boolean negation expressions of the form `!e` where `e` is an
expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>7</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>!</tt></b>&nbsp;&nbsp;<a href="#Expression7"><em>expr<sub>7</sub></em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression8"><em>expr<sub>8</sub></em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>!</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

A boolean negation expression is type checked by checking the type of the
subexpression.  It is a type error if this type is not `Boolean`.  The type of
the expression will be `Boolean`.

Negation expressions are evaluated by evaluating the subexpression.  The value
of the expression will be `true` if the value of the subexpression is `false`
and vice versa.  The subexpression will have a boolean value because the
expression is well-typed.

### Element and member access expressions and ledger expressions

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>8</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression8"><em>expr<sub>8</sub></em></a>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression8"><em>expr<sub>8</sub></em></a>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression8"><em>expr<sub>8</sub></em></a>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Expression9"><em>expr<sub>9</sub></em></a></td></tr></tbody></table>

Compact has expressions for accessing the elements of tuple values and the
members of structure values.  An expression of the form `e[n]` where `e` is an
expression and `n` is a numeric literal is a tuple element access.  An
expression of the form `e.id` where `e` is an expression and `id` is the name of
a structure member is a structure member access.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<em>nat</em>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em></td></tr></tbody></table>

Tuple element accesses are type checked by checking the type of the
subexpression.  It is a type error if this type is not a tuple type `[T, ...]`.
It is a type error if the length of the tuple is less than or equal to the
numeric literal in the expression.  The type of the expression is the
corresponding element type `T` at position `n` in the tuple type.

Tuple element accesses are evaluated by evaluating the subexpression.  The
value of the expression will be the element value at the given zero-based
index.  The subexpression will have a tuple value and the element access will
not be out of bounds, because the expression is well-typed.

Member access expressions are type checked by checking the type of the
subexpression.  It is a type error if this type is not a structure type.  It is
a type error if the structure type does not contain a member with the same name
as the name in the expression.  The type of the expression is the type of the
corresponding named member of the subexpression's structure type.

Member access expressions are evaluated by evaluating the subexpression.  The
value of the expression will be the member value with the given name.  The
subexpression will have a structure value and the name will exist, because the
expression is well-typed.


A Compact program interacts with its public state by invoking operations upon
the ledger or ledger state types.  There are two different forms of ledger
calls.

__Kernel operations__ are operations that do not depend on specific ledger
state.  They can be invoked by expressions of the form `k.op(e, ...)`, where
`k` is the name of a ledger field declared to have the special ADT type `Kernel`,
`op` is the name of a builtin kernel operation and
`e, ...` is a comma separated sequence of zero or more argument expressions.
The `CompactStandardLibrary` predefines the ledger field name `kernel` to have
ledger type `Kernel`, so for example, the built-in `self` operation can be called
from a circuit as follows:

```compact
import CompactStandardLibrary;
circuit f(): ContractAddress {
  return kernel.self();
}
```

__Ledger ADT operations__ are operations on the program's public ledger state.
They are invoked by expressions of the form `member.op(e, ...)....`,
where `member` is a ledger field name ([declared via a `ledger` field declaration](#declaring-and-maintaining-public-state))
and `.op(e, ...)....` are a sequence of zero or more ledger
ADT operation invocations, where each `op` is the name of a ledger ADT
operation and each `e, ...` is a sequence of zero or more comma-separated
argument expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<em>ledger-accessor</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;\{<em>ledger-accessor</em>}</td></tr><tr><td><em>ledger-accessor</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

Note that ledger ADT operations can be chained, because the result of a ledger
ADT operation might itself have a ledger state type.  Kernel operations cannot
be chained, because the kernel is not a ledger state type and is not returned
by any operation.

The static type of a kernel operation expression is the return type of the
corresponding kernel operation according to the ledger data types reference.

The static type of a ledger ADT operation expression is the return type of the
corresponding ADT operation according to the ledger data types reference.  Note
that this might be a Compact type or it might be a ledger ADT type.  Values of
ledger ADT types can have ADT operations invoked (immediately) on them, but
any other use would be a static type error.

Kernel operations are evaluated by evaluating the argument subexpressions in
order from left to right and then invoking the corresponding kernel operation
with the argument values.

A ledger ADT operation `member` (that is not followed by a ledger
accessor) is implicitly an invocation of the `read` operation.  It is evaluated
as if it were `member.read()`.

A ledger ADT operation `member.op(e, ...)` is evaluated by evaluating the
argument subexpressions from left to right, and then invoking the operation
`op` on the public ledger member `member` with the argument values.

A ledger ADT operation `adt.op(e, ...)` where `adt` is itself a ledger ADT
operation is evaluated by first evaluating `adt`, then evaluating the argument
subexpressions from left to right, and then invoking the operation `op` on the
ledger ADT value of `adt` with the argument values.

### Circuit and witness calls, map, fold, data creation, assert, and disclose

<table className="lang-ref-table"><tbody><tr><td><em>expr<sub>9</sub></em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Function"><em>fun</em></a>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>map</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Function"><em>fun</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b> &mldr;&sup1; <b><tt>,</tt></b> <a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>fold</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Function"><em>fun</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b> &mldr;&sup1; <b><tt>,</tt></b> <a href="#Expression"><em>expr</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>slice</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Type-size"><em>tsize</em></a>&nbsp;&nbsp;<b><tt>></tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<a href="#Tuple-argument"><em>tuple-arg</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Tuple-argument"><em>tuple-arg</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>Bytes</tt></b>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<a href="#Tuple-argument"><em>bytes-arg</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Tuple-argument"><em>bytes-arg</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Type-reference"><em>tref</em></a>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;<a href="#Structure-argument"><em>struct-arg</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Structure-argument"><em>struct-arg</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>}</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>assert</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#string-literal"><em>str</em></a>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>disclose</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Term"><em>term</em></a></td></tr></tbody></table>

<table className="lang-ref-table"><tbody><tr><td><em>tuple-arg</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>...</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr>
<tr><td><em>struct-arg</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>...</tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr>
<tr><td><em>fun</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a>&nbsp;&nbsp;<a href="#Generic-argument-list"><em>gargs</em></a><sup>opt</sup></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Arrow-parameter-list"><em>arrow-parameter-list</em></a>&nbsp;&nbsp;<a href="#Return-type"><em>return-type</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>=></tt></b>&nbsp;&nbsp;<a href="#Block"><em>block</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#Arrow-parameter-list"><em>arrow-parameter-list</em></a>&nbsp;&nbsp;<a href="#Return-type"><em>return-type</em></a><sup>opt</sup>&nbsp;&nbsp;<b><tt>=></tt></b>&nbsp;&nbsp;<a href="#Expression"><em>expr</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Function"><em>fun</em></a>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr>
<tr><td><em>return-type</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a></td></tr></tbody></table>
<table className="lang-ref-table"><tbody><tr><td><em>arrow-parameter-list</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Optionally-typed-pattern"><em>optionally-typed-pattern</em></a> <b><tt>,</tt></b> &mldr; <b><tt>,</tt></b> <a href="#Optionally-typed-pattern"><em>optionally-typed-pattern</em></a> <b><tt>,</tt></b><sup>opt</sup>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

#### Circuit and witness calls

Circuits and witnesses, collectively referred to as functions, are called via an
expression of the form `f(e, ...)`, where `f` is a function and `e, ...` is a
sequence of zero or more comma-separated argument expressions.



<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td><em>fun</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<em>targs</em>]</td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>parg</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>parg</em>}]&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;[<em>type</em>]&nbsp;&nbsp;<b><tt>=></tt></b>&nbsp;&nbsp;<em>body</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td><em>body</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>block</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

The function expression can take several different forms:

A **function name** is the name of a circuit or witness from a circuit or
witness declaration in scope.

An **anonymous circuit** is an inline circuit definition having the form `(P,
...) => body` or `(P, ...): R => body`, where `P, ...` are zero or more
comma-separated parameter declarations, `R` is an optional return type
annotation, and `body` is the circuit's body. Each parameter consists of either
an identifier `x` (the parameter's name) or a [destructured
pattern](#destructuring-tuples-and-structures) `[x, y]` or `{x, y}` for
parameters that have a tuple or a structure type, respectively, and an optional
type annotation `: T` where `T` is a Compact type. The optional return type `R`
is a Compact type. The body is either a block (a sequence of zero or more
semicolon-delimited statements enclosed in curly braces (`{ }`)), or an
expression.

There is no syntax for generic anonymous circuits.  This is because circuits are
not first-class values: they cannot be passed around or stored in data
structures, they *must* be called.  And generic circuits must be specialized to
call them, so anonymous generic circuits would have to be immediately
specialized.  In that case, the programmer can just write the non-generic
version themselves.

A **parenthesized function** has the form `(f)` where `f` is a function
expression, that is either a function name, an anonymous circuit, or a
parenthesized function.

Because functions are not first class, parameter names and constant names are
not allowed as the function part of a call.  Nor are arbitrary expressions
allowed, for the same reason.

Because circuits and witnesses are not first class, parameter names and constant
names are not allowed as the circuit or witness part of a call.  Nor are
arbitrary expressions allowed, for the same reason.

Generic functions cannot be called without explicitly specializing them with
generic arguments enclosed in angle brackets.  Calls to generic functions must
be fully specialized: the number of generic arguments must match the number of
generic parameters.

The *underlying function* of a function expression is a non-parenthesized
function expression.  For a function name it is the function name, for an
anonymous circuit it is the anonymous circuit, and for a parenthesized function
it is the underlying function of the parenthesized function expression.

Type checking a function call depends on the form of the underlying function.

* **For a named function:** Function names may be *overloaded*: more than one
  function of the same name may be present in the scope of a call to that
  function.  A call whose underlying function is a name can thus have zero or
  more candidate functions, i.e., all of those that have the given name and are
  present in the scope of the call.

  A candidate function is not necessarily compatible with the number and kinds
  of the generic parameter values, nor with the number and types of the argument
  expressions provided at the call site.  It is compatible if and only if the
  number of generic parameters is the same as the number of generic arguments,
  each generic argument is of the required kind (a size or a type), the number
  of declared parameters is the same as the number of argument expressions, and
  if the declared type of each parameter is a supertype of the corresponding
  argument expression.  If exactly one candidate is compatible, the call is made
  to that candidate.  It is a static type error otherwise (if there is not
  exactly one compatible candidate).

  The static type of a call to a named function is the return type of the called
  function.

* **For an anonymous circuit:** Parameters that have type annotations will be
  type checked, and parameters that do not have type annotations will have types
  inferred.  The argument subexpressions are type checked and then:

  - If there is a type annotation for a parameter, it is a static type error if
    the type of the corresponding argument expression is not a subtype of the
    type annotation.

  - If there is no type annotation for a parameter, the parameter's type is
    inferred as the type of the corresponding argument expression.

  If there is a return type annotation, then the circuit's body is type checked
  under the assumption that the parameters have their declared or inferred
  types.  It is a static type error if there is a returned subexpression whose
  static type is not a subtype of the return type annotation.  A return
  statement of the form `return;` is type checked as if it returned a value of
  type `[]`.  Every control flow path through a body that does not explicitly
  end with a return statement implicitly ends with one of the form `return;`.

  If there is no return type annotation, then a return type is inferred from the
  body.  The body is type checked under the assumption that the parameters have
  their declared or inferred types.  The inferred return type is the least upper
  bound of the types of all the returned subexpressions, with the same treatment
  of `return;` and control-flow paths that do not end in an explicit return as
  described above.

  The static type of a call to an anonymous circuit is the declared or inferred
  return type.

Calls are evaluated by evaluating the argument expressions in order from left to
right.  Then, if a circuit is being called, the statements in the body of the
circuit are executed with the parameter names bound to the corresponding
argument values.  The value of a circuit call is the value returned from the
execution of the body.  If a witness is being called, the contract will invoke
the TypeScript or JavaScript witness function with the argument values.  The
value of a witness call is the value returned by the witness function.

#### Map and fold expressions

Compact supports expressions that perform the higher-order operations _map_ and
(left) _fold_ over tuples that have a vector type (not arbitrary tuples).

Map expressions have the form `map(f, e, e, ...)` where `map` is a keyword, `f`
is a circuit or witness taking at least one argument, and the `e`s are
expressions.  A circuit or witness taking _n_ arguments can be mapped over _n_
argument vectors by providing _n_ vector subexpressions to the `map`.

Fold expressions have the form `fold(f, init, e, e, ...)` where `fold` is a
keyword, `f` is a circuit or witness, and `init` and the `e`s are expressions.
A circuit or witness taking _n_+1 arguments can be folded over an initial value
`init` and _n_ vectors by providing _n_ vector subexpressions to the `fold`.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>map</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<b><tt>fold</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

The syntax of the circuit or witness is given by the grammar production for
_fun_ in the section **Circuit and witness calls** above.

A map expression is type checked by checking the type of the witness or circuit
`f` to find its parameter types and its return type `R`.  `f` must have at least
one parameter.  The map expression must have the same number of vector subexpressions
as the number of parameters of `f`.  Each of the vector subexpressions
must have a vector type and all these vector types must have the same length
`n`.  If the type of the *i*th parameter to `f` is `T`, then the type of the
*i*th vector subexpression must be `Vector<n, S>` where `S` is a subtype of
`T`.  The type of entire expression is `Vector<n, R>`.

A fold expression is type checked by checking the type of the witness or circuit
`f` to find its parameter types and its return type `R`.  `f` must have at least
two parameters, and the type of the first parameter must be the same type as the
return type `R`.  The fold expression must have one fewer vector subexpression
than the number of parameters of `f`.  The subexpression `e` gives the initial
value for the fold.  It must have a type which is a subtype `R`.  Each of the
vector subexpressions must have a vector type and all these vector types must
have the same length `n`.  If the type of the *i*+1th parameter of `f` is `T`
then the type of the *i*th vector subexpression must be `Vector<n, S>` where `S`
is a subtype of `T`.  The type of the entire expression is `R`.

Map expressions are evaluated by evaluating the vector subexpressions from left
to right.  These values are the input vector values.  The witness or circuit `f`
is then applied in turn, from index 0 up to index `n`-1, to arguments taken from
the input vector values.  The result is a vector of length `n` where each *i*th
element is the result of applying `f` to the *i*th element of the corresponding
input vector values.

Fold expressions are evaluated by evaluating the initial value expression `e`
and then evaluating the vector subexpressions from left to right.  The values of
the vector expressions are the input vector values.  The witness or circuit `f`
is then applied in turn, from index 0 up to index `n`-1, to an accumulator value
argument and arguments taken from the input vector values.  The 0th (initial)
accumulator value is the value of the expression `e`, and each subsequent
*i*+1th accumulator value is the result of applying `f` to the *i*th accumulator
value and to the *i*th element of the corresponding input vector values.  The
result is the `n`th (final) accumulator value where `n` is the length of the
input vectors.

#### Slices

#### Structure creation

Structure values are created with structure creation expressions.  The
expression `S {f, ...}` is a structure creation expression, where `S` is a
structure type and `f, ...` is a sequence of zero or more comma-separated field
value specifiers.

A field value specifier can be one of three things:

* A **positional** field value is an expression.  Evaluating the expression
  gives the value for the field.  Positional field values must be given in the
  order that fields are declared in the corresponding structure declaration.
* A **named** field value is of the form `id: e` where `id` is a field name and
  `e` is an expression.  Evaluating the expression gives the value for the
  corresponding named field.  Named fields can appear in any order.  If named
  and positional fields are mixed, all the named fields must appear after all
  the positional fields.
* A **spread** expression is of the form `...e` where `...` is the literal three
  dots (ellipsis) token and `e` is an expression.  Evaluating the expression
  must give a value of the same structure type as the one being created.  The
  fields of the created structure are given values from the spread structure as
  described below.  If there is a spread expression, it must occur as the first
  field value specifier and all other specifiers must be named field values.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>tref</em>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;[<em>new-field</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>new-field</em>}]&nbsp;&nbsp;<b><tt>}</tt></b></td></tr><tr><td><em>new-field</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>...</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td><em>tref</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<em>targs</em>]</td></tr></tbody></table>

The examples below demonstrate the use of positional and spread field values:

```compact
struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }
circuit f(x: Uint<32>, y: Boolean, z: Bytes<8>): S {
  const s1 = S { c: z, a: x, b: y };
  // Alternatively, s1 can be created with the positional syntax S { x, y, z }
  // or a mix of positional and named field values S { x, c: z, b: y }.

  const s2 = S { ...s1, b: true };
  // s2 is created using the spread syntax.  So, s2 has the same field values
  // as s1 except that b is true.

  const s3 = S { ...s2, c: 'abcdefgh' };
  // s3 is also created using the spread syntax.  s3 has the same field values
  // as s2 except that c is 'abcdefgh'.

  return s3;
}
```

The structure type must come from a structure declaration in scope.  If the
structure is generic, then it must be explicitly specialized with generic
arguments enclosed in angle brackets.  Generic structures must be fully
specialized: the number of generic arguments must match the number of generic
parameters.

The static type of a non-generic structure creation expression is the named
structure type.

The generic arguments to a generic structure can be types, natural number
literals, or the names of generic parameters in scope.  A generic structure
creation expression is type checked by substituting the generic arguments for
the generic parameters in the structure's definition.  The static type of a
generic structure creation expression is a structure with the same name as the
generic type and field types obtained by substituting the generic arguments for
the generic parameters in the structure's declaration.

**If there is no spread field specifier:** It is a static error if the number of
field specifiers does not match the number of fields in the corresponding
structure declaration (a value must be given for every field).  It is a static
error if a named field specifier occurs before a positional field specifier.  It
is a static error if a field name occurs more than once, and it is a static
error if a field name occurs that is not the name of a field in the
corresponding structure declaration.  It is a static type error if the type of a
positional field subexpression is not a subtype of the declared type of the
(positionally) corresponding field in the structure declaration.  It is a static
type error if the type of a named field subexpression is not a subtype of the
declared type of the corresponding (named) field in the structure declaration.

**If there is a spread field specifier:** It is a static error if the spread
field specifier does not come first in the sequence.  It is a static type error
if the type of the spread subexpression is not the same type as structure to be
created.  It is a static error if there are any positional field specifiers.  It
is a static error if a field name occurs that is not the name of a field in the
corresponding structure declaration.  It is a static type error if the type of a
named field subexpression is not a subtype of the declared type of the
corresponding (named) field in the structure declaration.

A structure creation expression is evaluated by evaluating the field specifier
subexpressions in order from left to right.  The result is a structure value
whose fields have values based on the corresponding field specifier: if there is
a positional or named field specifier for the field, the field value is the
value of the subexpression, otherwise there must be a spread expression and the
field value is the value of the corresponding field in the (structure) value of
the spread subexpression.

#### Tuple creation

Tuple values are created with expressions of the form `[e, ...]` where `e, ...`
is a sequence of zero or more comma-separated argument expressions.  A non-empty
sequence can have an optional trailing comma.  The *length* of a tuple is the
number of subexpressions in the tuple creation expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;[<b><tt>,</tt></b>]&nbsp;&nbsp;<b><tt>]</tt></b></td></tr></tbody></table>

The static type of a tuple creation expression is `[T, ...]` with the number of
types matches length of the tuple and each type `T` is the type of the
corresponding expression.

It is evaluated by evaluating the subexpressions from left to right.  Its value
is a tuple whose length is the number of subexpressions and whose elements are
the subexpression values.

#### Asserts

An assertion has the form `assert(e, "msg")` where `e` is an expression and `msg` is a string message.
`e` must have a Boolean type, otherwise it is a static type error.  If `e` evaluates to `true`, the assertion
succeeds. If `e` evaluates to `false`, the assertion fails with the message `msg`.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>assert</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em></td><td><b><tt>,</tt></b>&nbsp;&nbsp;<b><tt>"</tt></b><em>msg</em>&nbsp;<b><tt>"</tt></b>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

Each assertion is checked at runtime and constrained in-circuit.

#### Discloses

### Terms

<table className="lang-ref-table"><tbody><tr><td><em>term</em>&nbsp;</td><td>&rarr;</td><td>&nbsp;&nbsp;<a href="#identifier"><em>id</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>true</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>false</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#field-literal"><em>nat</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<a href="#string-literal"><em>str</em></a></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>pad</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#field-literal"><em>nat</em></a>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<a href="#string-literal"><em>str</em></a>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<a href="#Type"><em>type</em></a>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<a href="#Expression-sequence"><em>expr-seq</em></a>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

#### Variable references

The syntax of Compact identifiers is the same as the syntax of TypeScript
identifiers.  A variable is an identifier that is bound as a parameter in a
circuit declaration or else as a constant in a `const` binding statement.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em></td></tr></tbody></table>

__Circuit parameters__ are bound by circuit declarations. The static type of a
circuit parameter reference is the declared static type given by the parameter
declaration's type annotation. It evaluates to the value of the corresponding
argument expression that was passed to the circuit call.

__Constants__ are bound by `const` binding statements. If the binding statement
has a type annotation, then the constant reference's static type is the declared
static type given by the type annotation, and the type of the right-hand side
initializer expression must be a subtype of the declared type. If the binding
statement does not have a type annotation, then the constant reference's static
type is the inferred static type (that is, the type of the binding statement's
initializer expression). A constant reference evaluates to the value of the
binding statement's initializer expression.

Note that constant references can have ledger state types because they can be
initialized with a ledger state type's default value.

#### Literals

Compact has syntax for boolean, numeric, and string literal expressions.


<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>true</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>false</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>nat</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>str</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>pad</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>nat</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>str</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

__Boolean literals__ are the reserved words `true` and `false`. The static type
of a boolean literal is `Boolean`. It evaluates to one of the two boolean
values.

__Numeric literals__ are non-negative decimal integers.  They are either the
number `0` or a sequence of digits starting with a non-zero digit.  The static
type of a natural number literal `n` is `Uint<0..n>`.

There is an implementation-defined maximum unsigned integer value.  A numeric
literal larger than this value will have an invalid static type `Uint<0..n>` for
some `n` larger than the maximum unsigned integer.  This expression will be a
static type error unless the literal is smaller than the maximum `Field` value
and is used in a type cast expression of the form `e as Field`.

A natural number literal evaluates to the unsigned integer value that it
denotes.

__String literals__ use TypeScript string literal syntax. Note that they can
therefore be enclosed in either single (`'`) or double (`"`) quotes, and they
can contain escaped characters. Strings are represented by their UTF-8 encoding.
The **length** of a string is the length of its UTF-8 encoding. The static type
of a string literal is `Bytes<n>` where `n` is the length of the string. It
evaluates to a byte array containing its UTF-8 encoding.

In addition, the expression `pad(n, s)` is a string literal, where `pad` is a
reserved word, `n` is a natural number literal and `s` is a string literal whose
length must be less than or equal to `n`. The static type of a padded string
literal `pad(n, s)` is `Bytes<n>`. It evaluates to a byte array containing the
UTF-8 encoding of `s`, followed by `0` bytes up to the padded length `n`.

#### Default values of a type

Every Compact type and ledger state type has a default value.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>type</em>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>ledger-adt</em>&nbsp;&nbsp;<b><tt>></tt></b></td></tr></tbody></table>

The expression `default<T>`, where `T` is a Compact type or a ledger state type,
has static type `T`. It evaluates to the default value of that type.

Note that default value expressions can have ledger state types.

#### Parenthesized expressions

Compact allows parenthesized expressions of the form `(e)`, where `e` is an
expression.  They can be used to control the order of evaluation.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

The type of the parenthesized expression is the type of the subexpression.

Its value is the value of the subexpression.

## Runtime representations and type/bounds checks

The TypeScript type representing a Compact type is defined in [Representations
in TypeScript](#representations-in-typescript).

Compact represents values exactly as TypeScript represents values, i.e., as
ordinary JavaScript values.  So a Compact boolean is represented at run time
as a JavaScript boolean, a Compact tuple is represented as a JavaScript
array, and enum values are represented by numbers.

To maintain type safety, Compact verifies at run time that values
passed by an outside caller to an exported circuit or returned from an
outside witness have the expected types.
This is necessary even when the caller or witness is written in properly
typed TypeScript because some Compact types have size and range limits
that are not expressible via the TypeScript type system:

- `Field` values are limited by a maximum field value
- `Uint` values are limited by the declared bounds
- `Bytes` and tuple values are limited by their lengths
- enum values are limited by the maximum index for the enum elements

It is also necessary because compile-time type checks are easily
defeated in TypeScript and are nonexistent when a caller or witness
is coded in JavaScript.

Certain values to be stored in public state require size, length, and other
properties to be maintained explicitly, because these properties cannot
be determined solely from the JavaScript representation of the value.
For this purpose, the `@midnight/compact-runtime` package provides explicit
runtime types satisfying the `CompactType<T>` interface, where `T` is the
corresponding TypeScript type.
This representation is *not* user-facing most of the time, except
when replicating the behavior of the operations implemented
in `@midnight/compact-runtime`.

The following constructors can be used to create a `CompactType` instance
for a primitive type:

- `Boolean` - `new CompactTypeBoolean()`
- `Field` - `new CompactTypeField()`
- `Uint<0..n>` - `new CompactTypeUnsignedInteger(n, length)`, where
  `length` is the number of bytes required to store `n`
- `Uint<n>` - as `Uint<0..(2 ** n) - 1>`
- `Bytes<n>` - `new CompactTypeBytes(n)`
- `Vector<n, T>` - `new CompactTypeVector(n, rt_T)`, where `rt_T` is the runtime
  type of `T`
- `Opaque<"String">` - `new CompactTypeString()`
- `Opaque<"Uint8Array">` - `new CompactTypeUint8Array()`.

For program-defined types, structures are not currently easily
constructed at runtime and require implementing `CompactType<T>`
manually or using compiler internals.  Enumerations are exposed
through `new CompactTypeEnum(maxValue, length)`, where `maxValue` is
the maximum permissible integer assignable, and `length` its
representation length in bytes (almost always 1).

## TypeScript target

When compiled, a contract generates several artifacts. Key to these
are the exported circuits from the contract's top level. These are
divided into two categories: [pure circuits and impure circuits](#pure-and-impure-circuits).

In the `contract` directory, the semantics of the contract is encoded in
TypeScript, in the form of a `index.js` JavaScript implementation file and a
`index.d.ts` type declaration file. For most uses, it is recommended to rely on the
information and interface provided in `index.d.ts`.

For each of the impure circuits, a zero-knowledge prover/verifier key pair is also
generated, as well as instructions for proof generation. These can be found
in the output directory's `keys` and `zkir` subdirectories respectively.

### Structure of the exported TypeScript

The exported TypeScript exposes a number of declarations that can be used
to interact with the contract from any TypeScript application. Some of these
also require use of the `@midnight/compact-runtime` library, which all
contracts depend upon and which implements key built-in behaviors.

A contract exports the following in the TypeScript module:

- The TypeScript type corresponding to each program-defined type exported from the
  contract's top level
- A `Witnesses<T>` type, which describes the format external witnesses must
  satisfy to instantiate the contract
- A `ImpureCircuits<T>` type, which describes the set of impure circuits exported
  from the contract's top level
- A `PureCircuits` type, which describes the set of pure circuits exported from
  the contract's top level
- A `Circuits<T>` type, which describes the set of all exported circuits
- A `Contract<T, W extends Witnesses<T> = Witnesses<T>>` class, which:
  - can be constructed by passing in an instance of `W`
  - exposes members `circuits: Circuits<T>` and `impureCircuits: ImpureCircuits<T>`
  - provides initial contract states via
    `initialState(privateState: T): [T, runtime.ContractState]`
- A constant `pureCircuits: PureCircuits` object, providing all pure circuits
  as pure functions
- A `Ledger` type, providing views into a current ledger state, by permitting
  direct calls of all read functions of `ledger` objects, as well of some
  TypeScript specific ones that cannot be called from Compact, such as iterators
- A `ledger(state: runtime.StateValue): Ledger` constructor of the `Ledger` type,
  giving access to the values of exported ledger fields.

The argument `T` for a number of these should be interpreted as the type of the
local/private state. For the most part, `circuit` and `witness` functions are
translated simply by translating their Compact types into corresponding
TypeScript types for parameters and return values. For `PureCircuits`, this is
all that happens, for the other `_Circuits` instances, they receive an
additional first parameter of type `runtime.CircuitContext<T>`, and their result
type `R` is wrapped in `runtime.CircuitResults<T, R>`. For `Witnesses`, they
receive an additional first parameter of type `runtime.WitnessContext<Ledger,
T>`, and their result type `R` is wrapped in `[T, R]`. See the [runtime API
docs](/docs/develop/reference/midnight-api/compact-runtime/README.md) for the
details of these types. This wrapping makes the entirety of the contract code
*functional*, ensuring calls have no hidden side effects.

### Representations in TypeScript

Compact's primitive types are represented in TypeScript as follows:

- `Boolean` - `boolean`
- `Field` - `bigint` with runtime bounds checks
- `Uint<n>` / `Uint<0..n>` - `bigint` with runtime bounds checks
- `[T, ...]` - the TypeScript tuple type `[S, ...]` or else the TypeScript array
  type `S[]` with runtime length checks, where `S` is the TypeScript
  representation of the corresponding type `T`
- `Bytes<n>` - `Uint8Array` with runtime length checks
- `Opaque<"string">` - `string`
- `Opaque<"Uint8Array">` - `Uint8Array`

Program-defined types are represented in TypeScript as follows:
- `enum` instances - a `number` with runtime membership checks
- `struct` instances with fields `a: A, b: B, ...` - an object `{ a: A, b: B, ... }`
  where `A`, `B`, ... are the TypeScript representations of the Compact types.

Note that other `Opaque` types are currently not supported.
