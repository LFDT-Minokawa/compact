# Expressions

This section describes the syntax of Compact expressions and provides their
static typing rules and their evaluation rules.

A Compact expression either has a static type, or else it contains a type error.
The static type of an expression, if it has one, is either a Compact type or
else a ledger state type.  If an expression in a program contains a type error,
it means that the Compact compiler will not compile that program.
Subexpressions of Compact expressions are always required to be well-typed
(free from type errors).

Every Compact expression either evaluates to a value, or else it raises an
exception.  The evaluation of an expression is defined in terms of the
evaluation of its subexpressions.  If the evaluation of a subexpression raises
an exception, then the evaluation of the containing expression will stop and
raise the same exception.

#### Literals

Compact has syntax for boolean, numeric, and string literal expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>true</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>false</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>nat</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>str</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>pad</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>nat</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>str</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

__Boolean literals__ are the reserved words `true` and `false`.
The static type of a boolean literal is `Boolean`.
It evaluates to one of the two boolean values.

__Numeric literals__ are non-negative decimal integers.  They are either the
number `0` or a sequence of digits starting with a non-zero digit.  The static
type of a natural number literal `n` is `Uint<0..n>`.

There is an implementation-defined maximum unsigned integer value.  A numeric
literal larger than this value will have an invalid static type `Uint<0..n>` for
some `n` larger than the maximum unsigned integer.  This expression will be a
static type error unless the literal is smaller than the maximum `Field` value
and is used in a type cast expression of the form `e as Field`.

A natural number literal evaluates to the unsigned integer value that it
denotes.

__String literals__ use TypeScript string literal syntax.  Note that they can
therefore be enclosed in either single (`'`) or double (`"`) quotes, and they
can contain escaped characters.  Strings are represented by their UTF-8
encoding.  The **length** of a string is the length of its UTF-8 encoding.
The static type of a string literal is `Bytes<n>` where `n` is the length of
the string.
It evaluates to a byte array containing its UTF-8 encoding.

In addition, the expression `pad(n, s)` is a string literal, where
`pad` is a reserved word, `n` is a natural number literal and `s` is a string
literal whose length must be less than or equal to `n`.
The static type of a padded string literal `pad(n, s)` is `Bytes<n>`.
It evaluates to a byte array containing the UTF-8 encoding of `s`, followed by
`0` bytes up to the padded length `n`.

#### Variable references

The syntax of Compact identifiers is the same as the syntax of TypeScript
identifiers.  A variable is an identifier that is bound as a parameter in a
circuit declaration or else as a constant in a `const` binding statement.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em></td></tr></tbody></table>

__Circuit parameters__ are bound by circuit declarations.
The static type of a circuit parameter reference is the declared static type
given by the parameter declaration's type annotation.
It evaluates to the value of the corresponding argument expression that was
passed to the circuit call.

__Constants__ are bound by `const` binding statements.  If the binding statement
has a type annotation, then the constant reference's static type is the declared
static type given by the type annotation, and the type of the right-hand side
initializer expression must be a subtype of the declared type.  If the binding
statement does not have a type annotation, then the constant reference's static
type is the inferred static type (that is, the type of the binding statement's
initializer expression).  A constant reference evaluates to the value of the
binding statement's initializer expression.

Note that constant references can have ledger state types because they can be
initialized with a ledger state type's default value.

#### Default values of a type

Every Compact type and ledger state type has a default value.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>type</em>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>ledger-adt</em>&nbsp;&nbsp;<b><tt>></tt></b></td></tr></tbody></table>

The expression `default<T>`, where `T` is a Compact type or a ledger state type,
has static type `T`.
It evaluates to the default value of that type.

Note that default value expressions can have ledger state types.

#### Circuit and witness calls

Circuits and witnesses, collectively referred to as functions, are called via an
expression of the form `f(e, ...)`, where `f` is a function and `e, ...` is a
sequence of zero or more comma-separated argument expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td><em>fun</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<em>targs</em>]</td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>parg</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>parg</em>}]&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;[<em>type</em>]&nbsp;&nbsp;<b><tt>=></tt></b>&nbsp;&nbsp;<em>body</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td><em>body</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>block</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

The function expression can take several different forms:

A **function name** is the name of a circuit or witness from a circuit or
witness declaration in scope.

An **anonymous circuit** is an inline circuit definition having the form `(P,
...) => body` or `(P, ...): R => body`, where `P, ...` are zero or more
comma-separated parameter declarations, `R` is an optional return type
annotation, and `body` is the circuit's body.  Each parameter consists of either an
identifier `x` (the parameter's name) or a
[destructured pattern](../parameters-patterns-and-destructuring#destructuring-tuples-and-structures) `[x, y]` or `{x, y}`
for parameters that have a tuple or a structure type, respectively,
and an optional type annotation `: T`
where `T` is a Compact type.  The optional return type `R` is a Compact type.
The body is either a block (a sequence of zero or more semicolon-delimited
statements enclosed in curly braces (`{ }`)), or an expression.

There is no syntax for generic anonymous circuits.  This is because circuits are
not first-class values: they cannot be passed around or stored in data
structures, they *must* be called.  And generic circuits must be specialized to
call them, so anonymous generic circuits would have to be immediately
specialized.  In that case, the programmer can just write the non-generic
version themselves.

A **parenthesized function** has the form `(f)` where `f` is a function
expression, that is either a function name, an anonymous circuit, or a
parenthesized function.

Because functions are not first class, parameter names and constant names are
not allowed as the function part of a call.  Nor are arbitrary expressions
allowed, for the same reason.

Because circuits and witnesses are not first class, parameter names and constant
names are not allowed as the circuit or witness part of a call.  Nor are
arbitrary expressions allowed, for the same reason.

Generic functions cannot be called without explicitly specializing them with
generic arguments enclosed in angle brackets.  Calls to generic functions must
be fully specialized: the number of generic arguments must match the number of
generic parameters.

The *underlying function* of a function expression is a non-parenthesized
function expression.  For a function name it is the function name, for an
anonymous circuit it is the anonymous circuit, and for a parenthesized function
it is the underlying function of the parenthesized function expression.

Type checking a function call depends on the form of the underlying function.

* **For a named function:** Function names may be *overloaded*: more than one
  function of the same name may be present in the scope of a call to that
  function.  A call whose underlying function is a name can thus have zero or
  more candidate functions, i.e., all of those that have the given name and are
  present in the scope of the call.

  A candidate function is not necessarily compatible with the number and kinds
  of the generic parameter values, nor with the number and types of the argument
  expressions provided at the call site.  It is compatible if and only if the
  number of generic parameters is the same as the number of generic arguments,
  each generic argument is of the required kind (a size or a type), the number
  of declared parameters is the same as the number of argument expressions, and
  if the declared type of each parameter is a supertype of the corresponding
  argument expression.  If exactly one candidate is compatible, the call is made
  to that candidate.  It is a static type error otherwise (if there is not
  exactly one compatible candidate).

  The static type of a call to a named function is the return type of the called
  function.

* **For an anonymous circuit:** Parameters that have type annotations will be
  type checked, and parameters that do not have type annotations will have types
  inferred.  The argument subexpressions are type checked and then:

  - If there is a type annotation for a parameter, it is a static type error if
    the type of the corresponding argument expression is not a subtype of the
    type annotation.

  - If there is no type annotation for a parameter, the parameter's type is
    inferred as the type of the corresponding argument expression.

  If there is a return type annotation, then the circuit's body is type checked
  under the assumption that the parameters have their declared or inferred
  types.  It is a static type error if there is a returned subexpression whose
  static type is not a subtype of the return type annotation.  A return
  statement of the form `return;` is type checked as if it returned a value of
  type `[]`.  Every control flow path through a body that does not explicitly
  end with a return statement implicitly ends with one of the form `return;`.

  If there is no return type annotation, then a return type is inferred from the
  body.  The body is type checked under the assumption that the parameters have
  their declared or inferred types.  The inferred return type is the least upper
  bound of the types of all the returned subexpressions, with the same treatment
  of `return;` and control-flow paths that do not end in an explicit return as
  described above.

  The static type of a call to an anonymous circuit is the declared or inferred
  return type.

Calls are evaluated by evaluating the argument expressions in order from left to
right.  Then, if a circuit is being called, the statements in the body of the
circuit are executed with the parameter names bound to the corresponding
argument values.  The value of a circuit call is the value returned from the
execution of the body.  If a witness is being called, the contract will invoke
the TypeScript or JavaScript witness function with the argument values.  The
value of a witness call is the value returned by the witness function.

#### Structure creation

Structure values are created with structure creation expressions.  The
expression `S {f, ...}` is a structure creation expression, where `S` is a
structure type and `f, ...` is a sequence of zero or more comma-separated field
value specifiers.

A field value specifier can be one of three things:

* A **positional** field value is an expression.  Evaluating the expression
  gives the value for the field.  Positional field values must be given in the
  order that fields are declared in the corresponding structure declaration.
* A **named** field value is of the form `id: e` where `id` is a field name and
  `e` is an expression.  Evaluating the expression gives the value for the
  corresponding named field.  Named fields can appear in any order.  If named
  and positional fields are mixed, all the named fields must appear after all
  the positional fields.
* A **spread** expression is of the form `...e` where `...` is the literal three
  dots (ellipsis) token and `e` is an expression.  Evaluating the expression
  must give a value of the same structure type as the one being created.  The
  fields of the created structure are given values from the spread structure as
  described below.  If there is a spread expression, it must occur as the first
  field value specifier and all other specifiers must be named field values.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>tref</em>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;[<em>new-field</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>new-field</em>}]&nbsp;&nbsp;<b><tt>}</tt></b></td></tr><tr><td><em>new-field</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>...</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td><em>tref</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<em>targs</em>]</td></tr></tbody></table>

The examples below demonstrate the use of positional and spread field values:

```compact
struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }
circuit f(x: Uint<32>, y: Boolean, z: Bytes<8>): S {
  const s1 = S { c: z, a: x, b: y };
  // Alternatively, s1 can be created with the positional syntax S { x, y, z }
  // or a mix of positional and named field values S { x, c: z, b: y }.

  const s2 = S { ...s1, b: true };
  // s2 is created using the spread syntax.  So, s2 has the same field values
  // as s1 except that b is true.

  const s3 = S { ...s2, c: 'abcdefgh' };
  // s3 is also created using the spread syntax.  s3 has the same field values
  // as s2 except that c is 'abcdefgh'.

  return s3;
}
```

The structure type must come from a structure declaration in scope.  If the
structure is generic, then it must be explicitly specialized with generic
arguments enclosed in angle brackets.  Generic structures must be fully
specialized: the number of generic arguments must match the number of generic
parameters.

The static type of a non-generic structure creation expression is the named
structure type.

The generic arguments to a generic structure can be types, natural number
literals, or the names of generic parameters in scope.  A generic structure
creation expression is type checked by substituting the generic arguments for
the generic parameters in the structure's definition.  The static type of a
generic structure creation expression is a structure with the same name as the
generic type and field types obtained by substituting the generic arguments for
the generic parameters in the structure's declaration.

**If there is no spread field specifier:** It is a static error if the number of
field specifiers does not match the number of fields in the corresponding
structure declaration (a value must be given for every field).  It is a static
error if a named field specifier occurs before a positional field specifier.  It
is a static error if a field name occurs more than once, and it is a static
error if a field name occurs that is not the name of a field in the
corresponding structure declaration.  It is a static type error if the type of a
positional field subexpression is not a subtype of the declared type of the
(positionally) corresponding field in the structure declaration.  It is a static
type error if the type of a named field subexpression is not a subtype of the
declared type of the corresponding (named) field in the structure declaration.

**If there is a spread field specifier:** It is a static error if the spread
field specifier does not come first in the sequence.  It is a static type error
if the type of the spread subexpression is not the same type as structure to be
created.  It is a static error if there are any positional field specifiers.  It
is a static error if a field name occurs that is not the name of a field in the
corresponding structure declaration.  It is a static type error if the type of a
named field subexpression is not a subtype of the declared type of the
corresponding (named) field in the structure declaration.

A structure creation expression is evaluated by evaluating the field specifier
subexpressions in order from left to right.  The result is a structure value
whose fields have values based on the corresponding field specifier: if there is
a positional or named field specifier for the field, the field value is the
value of the subexpression, otherwise there must be a spread expression and the
field value is the value of the corresponding field in the (structure) value of
the spread subexpression.

#### Tuple creation

Tuple values are created with expressions of the form `[e, ...]` where `e, ...`
is a sequence of zero or more comma-separated argument expressions.  A non-empty
sequence can have an optional trailing comma.  The *length* of a tuple is the
number of subexpressions in the tuple creation expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;[<b><tt>,</tt></b>]&nbsp;&nbsp;<b><tt>]</tt></b></td></tr></tbody></table>

The static type of a tuple creation expression is `[T, ...]` with the number of
types matches length of the tuple and each type `T` is the type of the
corresponding expression.

It is evaluated by evaluating the subexpressions from left to right.  Its value
is a tuple whose length is the number of subexpressions and whose elements are
the subexpression values.

#### Parenthesized expressions

Compact allows parenthesized expressions of the form `(e)`, where `e` is an
expression.  They can be used to control the order of evaluation.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

The type of the parenthesized expression is the type of the subexpression.

Its value is the value of the subexpression.

#### Sequence expressions

Expressions can be sequenced for their side effects.  An expression of the form
`(e0, e1, e2, ...)` or `e0, e1, e2, ...` where `e0, e1, e2, ...` is a sequence of two or more
comma-separated expressions is a sequence expression. The latter form where parentheses can
be omitted is only allowed in some context which can be viewed in
[the formal grammar of Compact](./compact-grammar).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;</td></tr></tbody></table>

The static type of a sequence expression is the static type of the last
subexpression.

It is evaluated by evaluating the subexpressions from left to right.  Its value
is the value of the last subexpression.

#### Asserts

An assertion has the form `assert(e, "msg")` where `e` is an expression and `msg` is a string message.
`e` must have a Boolean type, otherwise it is a static type error.  If `e` evaluates to `true`, the assertion
succeeds. If `e` evaluates to `false`, the assertion fails with the message `msg`.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>assert</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em></td><td><b><tt>,</tt></b>&nbsp;&nbsp;<b><tt>"</tt></b><em>msg</em>&nbsp;<b><tt>"</tt></b>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

Each assertion is checked at runtime and constrained in-circuit.

#### Ledger expressions

A Compact program interacts with its public state by invoking operations upon
the ledger or ledger state types.  There are two different forms of ledger
calls.

__Kernel operations__ are operations that do not depend on specific ledger
state.  They can be invoked by expressions of the form `k.op(e, ...)`, where
`k` is the name of a ledger field declared to have the special ADT type `Kernel`,
`op` is the name of a builtin kernel operation and
`e, ...` is a comma separated sequence of zero or more argument expressions.
The `CompactStandardLibrary` predefines the ledger field name `kernel` to have
ledger type `Kernel`, so for example, the built-in `self` operation can be called
from a circuit as follows:

```compact
import CompactStandardLibrary;
circuit f(): ContractAddress {
  return kernel.self();
}
```

__Ledger ADT operations__ are operations on the program's public ledger state.
They are invoked by expressions of the form `member.op(e, ...)....`,
where `member` is a ledger field name ([declared via a `ledger` field declaration](../declaring-and-maintaining-public-state))
and `.op(e, ...)....` are a sequence of zero or more ledger
ADT operation invocations, where each `op` is the name of a ledger ADT
operation and each `e, ...` is a sequence of zero or more comma-separated
argument expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<em>ledger-accessor</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;\{<em>ledger-accessor</em>}</td></tr><tr><td><em>ledger-accessor</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

Note that ledger ADT operations can be chained, because the result of a ledger
ADT operation might itself have a ledger state type.  Kernel operations cannot
be chained, because the kernel is not a ledger state type and is not returned
by any operation.

The static type of a kernel operation expression is the return type of the
corresponding kernel operation according to the ledger data types reference.

The static type of a ledger ADT operation expression is the return type of the
corresponding ADT operation according to the ledger data types reference.  Note
that this might be a Compact type or it might be a ledger ADT type.  Values of
ledger ADT types can have ADT operations invoked (immediately) on them, but
any other use would be a static type error.

Kernel operations are evaluated by evaluating the argument subexpressions in
order from left to right and then invoking the corresponding kernel operation
with the argument values.

A ledger ADT operation `member` (that is not followed by a ledger
accessor) is implicitly an invocation of the `read` operation.  It is evaluated
as if it were `member.read()`.

A ledger ADT operation `member.op(e, ...)` is evaluated by evaluating the
argument subexpressions from left to right, and then invoking the operation
`op` on the public ledger member `member` with the argument values.

A ledger ADT operation `adt.op(e, ...)` where `adt` is itself a ledger ADT
operation is evaluated by first evaluating `adt`, then evaluating the argument
subexpressions from left to right, and then invoking the operation `op` on the
ledger ADT value of `adt` with the argument values.

#### Element and member access expressions

Compact has expressions for accessing the elements of tuple values and the
members of structure values.  An expression of the form `e[n]` where `e` is an
expression and `n` is a numeric literal is a tuple element access.  An
expression of the form `e.id` where `e` is an expression and `id` is the name of
a structure member is a structure member access.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<em>nat</em>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em></td></tr></tbody></table>

Tuple element accesses are type checked by checking the type of the
subexpression.  It is a type error if this type is not a tuple type `[T, ...]`.
It is a type error if the length of the tuple is less than or equal to the
numeric literal in the expression.  The type of the expression is the
corresponding element type `T` at position `n` in the tuple type.

Tuple element accesses are evaluated by evaluating the subexpression.  The
value of the expression will be the element value at the given zero-based
index.  The subexpression will have a tuple value and the element access will
not be out of bounds, because the expression is well-typed.

Member access expressions are type checked by checking the type of the
subexpression.  It is a type error if this type is not a structure type.  It is
a type error if the structure type does not contain a member with the same name
as the name in the expression.  The type of the expression is the type of the
corresponding named member of the subexpression's structure type.

Member access expressions are evaluated by evaluating the subexpression.  The
value of the expression will be the member value with the given name.  The
subexpression will have a structure value and the name will exist, because the
expression is well-typed.

#### Boolean negation expressions

Compact has unary boolean negation expressions of the form `!e` where `e` is an
expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>!</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

A boolean negation expression is type checked by checking the type of the
subexpression.  It is a type error if this type is not `Boolean`.  The type of
the expression will be `Boolean`.

Negation expressions are evaluated by evaluating the subexpression.  The value
of the expression will be `true` if the value of the subexpression is `false`
and vice versa.  The subexpression will have a boolean value because the
expression is well-typed.

#### Binary arithmetic expressions

Binary arithmetic expressions are of the form `e0 op e1` where `e0` and `e1`
are expressions and `op` is one of Compact's binary arithmetic operators.  The
binary arithmetic operators are **add** (`+`), **subtract** (`-`) and
**multiply** (`*`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>+</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>-</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>*</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Arithmetic expressions require the type of both subexpressions to be numeric
types, that is, either a `Field` or a `Uint`.  The type of the result will
depend on the types of the subexpressions as follows:

- If either subexpression has type `Field`, the result will have type `Field`
- Otherwise the left subexpression will have type `Uint<0..m>` and the right
  subexpression will have type `Uint<0..n>` for some bounds `m` and `n`. The
  type of the result depends on the operation as follows:
  - For add, the result will have type `Uint<0..m+n>`
  - For subtract, the result will have type `Uint<0..m>`
  - For multiply, the result will have type `Uint<0..m*n>`

For arithmetic operations with `Uint` result types, it is a static type error if
the result's bound would be greater than the maximum unsigned integer.

Arithmetic expressions are evaluated by first evaluating the subexpressions in
order from left to right.  Integer addition, subtraction, or multiplication is
then used on the subexpression values.  The overflow and underflow behavior
differs for `Field` and `Uint` operations:

- `Field` arithmetic overflow and underflow wraps around 0; that is, the result
  of an arithmetic operation whose result is a `Field` is the actual arithmetic
  value modulo `k`, where `k` is one more than the maximum field value.
- `Uint` addition and multiplication cannot overflow: the static type of the
  result will always be large enough to hold the result value
- `Uint` subtraction checks if the value of the right subexpression is greater
  than the value of the left subexpression.  If so, it is a runtime error (the
  result would be negative).  Otherwise the unsigned subtraction is performed.

The static typing rules imply that if `Field` arithmetic semantics is desired,
then at least one of the operands must have static type `Field`.

#### Type cast expressions

Type cast expressions in Compact are of the form `e as T` where `e` is an
expression, `as` is a reserved words, and `T` is a Compact type.

TypeScript-style casts of the form `<T>e` are not supported in Compact.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>as</tt></b>&nbsp;&nbsp;<em>type</em></td></tr></tbody></table>

Type cast expressions are type checked by checking the type of the
subexpression.  If the cast from the subexpression's type to the
type `T` named in the type cast is allowed, then the static type
of the expression will be `T`.  Otherwise, it is a static type
error.

Upcasts, i.e., casts from a type to a supertype, are allowed but
never required and never result in a static or run-time error.

The table below describes the allowed type casts.  Casting between
types not shown in the table is not allowed.  The entries in the
table can be one of:

- **static:** the type cast only changes the static type and does
  not have any effect at runtime
- **conversion:** the type cast always succeeds but has the runtime
  effect of converting between different source and target
  representations, which normally has a low cost
- **checked:** the type cast is checked at runtime and can fail
- **no:** the type cast is not allowed
- a number: see the corresponding note below the table

<table>
  <thead>
    <tr>
      <th colspan="2"></th>
      <th colspan="4">TO</th>
    </tr>
    <tr>
      <th colspan="2"></th>
      <th><tt>Field</tt></th>
      <th><tt>Uint\<0..n></tt></th>
      <th><tt>Boolean</tt></th>
      <th><tt>Bytes\<n></tt></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5">FROM</th>
      <th><tt>Field</tt></th>
      <td>static</td>
      <td>checked</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th><tt>Uint\<0..m></tt></th>
      <td>static</td>
      <td>3</td>
      <td>conversion</td>
      <td>no</td>
    </tr>
    <tr>
      <th>enum type</th>
      <td>conversion</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
    <tr>
      <th><tt>Boolean</tt></th>
      <td>conversion</td>
      <td>4</td>
      <td>no</td>
      <td>no</td>
    </tr>
    <tr>
      <th><tt>Bytes\<m></tt></th>
      <td>5</td>
      <td>no</td>
      <td>no</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

1. `Field` to `Boolean`: the value `0` is converted to `false` and all other
   values are converted to `true`.
2. `Field` to `Bytes<n>`: the value of the field is converted into `Bytes` of
   the given length, with the least-significant byte of the field occurring
   first in the `Bytes`. The `Bytes` will be padded to the length with trailing
   zeros.  It is a runtime error if the field value does not fit in the length.
3. `Uint<0..m>` to `Uint<0..n>`: if `m` is less than or equal to `n` this is a
   static cast.  Otherwise it is checked and will fail at runtime if the value
   is greater than `n`.
4. `Boolean` to `Uint<0..n>`: If `n` is not 0 then this is a conversion of
   `false` to 0 and `true` to 1. Otherwise, it is checked and will fail at
   runtime if the value is `true` (and convert `false` to 0).
5. `Bytes<m>` to `Field`: the bytes are converted into a field with the
   least-significant byte of the field occurring first in the `Bytes`.  It is a
   runtime error if the result would exceed the maximum `Field` value.
6. `Bytes<m>` to `Bytes<n>`: the cast is a static cast if `m` equals `n`, and is
   not allowed otherwise.

Allowed type casts are evaluated by first evaluating the subexpression.
Then, if the cast is static, the result is the subexpression's value
interpreted as the type `T` mentioned in the cast expression.  If the
cast is a conversion, the JavaScript representation of the subexpression's
value is converted into the representation of a value of type `T`. If the
cast is checked, the check is performed before conversion and the cast
fails (at runtime) if the check fails.  The exceptions noted in the table
are evaluated as described above after evaluating the subexpression.

#### Relational comparison expressions

Relational comparison expressions are of the form `e0 op e1` where `e0`
and `e1` are expressions and `op` is one of Compact's relational operators.
The relational operators are **equals** (`==`), **not equals** (`!=`), **less
than** (`<`), **greater than** (`>`), **less than or equals** (`<=`), and
**greater than or equals** (`>=`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>==</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>!=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Equals and not equals require the types of the subexpressions to be in the
subtype relation.  That is, the type of the first subexpression must be a
subtype of the type of the second subexpression, or else the type of the second
subexpression must be a subtype of the type of the first subexpression.

Less than, greater than, less than or equals, and greater than or equals require
the type of both subexpressions to be unsigned integer types (note that `Field`
cannot be compared with these operators).

The type of the result is `Boolean`.

Relational comparison expressions are evaluated by evaluating the subexpressions
in order from left to right.  Then the comparison is performed as described
below.

**Equals**

The comparison that is performed depends on the type of the operands:

- **`Boolean`:** if the operands have type `Boolean`, then the values must be
  the same boolean value.  Both operands will have type `Boolean` due to the static typing rules.
- **`Uint`:** if the operands have unsigned integer types, then the integer
  values must be equal.  Both operands will have unsigned integer types due to
  the static typing rules.
- **`Field`:** if either operand has type `Field`, then the integer values of
  the operands must be equal.  Both operands will have numeric (`Field` or
  unsigned integer) types due to the static typing rules.
- **`Bytes:`** if the operands have bytes types, then the corresponding bytes
  at each index must be equal.  Both operands will have bytes types and their
  lengths will be equal due to the static typing rules.
- **`Tuple:`** if the operands have tuple types, then the corresponding
  element values at each index must be equal according to these rules, based on
  the static element types.  Both operands will have tuple types, they will
  have the the same length, and their element types will be in the subtype
  relation due to the static typing rules.
- **`Opaque:`** if the operands have opaque types, then the runtime values
  must be equal according to JavaScript's strict equality (`===`) operator.
  Both operands will have the same opaque type due to the static typing rules.
- **structure type:** if the operands have structure types, then the
  corresponding values of each field must be equal according to these rules,
  based on the field types.  Both operands will have the same structure type due
  to the static typing rules.
- **enum type:** if the operands have enum types, then they must be the same
  enum value.  Both operands will have the same enum type due to the static
  typing rules.

**Not equals**

The operands are compared according to the rules for equals above, and then the
boolean result is negated.

**Less than, greater than, less than or equals, and greater than or equals**

The integer values of the operands are compared according to the relational
operation.  Both operands will have unsigned integer types due to the static
typing rules.

#### Short-circuit logical expressions

Compact supports short-circuit logical expressions of the form `e0 op e1`
where `e0` and `e1` are expressions and `op` is one of the logical operators
**or** (`||`) or **and** (`&&`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>||</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&amp;&amp;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Logical expressions require the type of the left subexpression to be `Boolean`.
The type of the right subexpression must be a supertype of `Boolean`.  The only
supertype of `Boolean` is `Boolean` itself.  The entire expression will have the
same type as the type of the right subexpression.

Logical expressions are evaluated by first evaluating the left subexpression.
Then, the value of that expression determines the value of the entire
expression as follows:

- For or, if the value of the left subexpression is `false` then the right
  subexpression is evaluated and its value is the value of the entire
  expression.  Otherwise, the right subexpression is **not** evaluated and the
  value of the left subexpression, implicitly cast to the type of the entire
  expression, is the value of the entire expression.
- For and, if the left subexpression is `true` then the right subexpression is
  evaluated and its value is the value of the entire expression.  Otherwise,
  the right subexpression is **not** evaluated and the value of the left
  subexpression, implicitly cast to the type of the entire expression, is the
  value of the entire expression.

#### Conditional expressions

Compact supports conditional expressions of the form `e0 ? e1 : e2` where `e0`,
`e1`, and `e2` are expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>?</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Conditional expressions require the type of `e0` to be `Boolean`.  The types of
`e1` and `e2` must be in the subtype relation.  That is, either the type of
`e1` is a subtype of the type of `e2` or else the type of `e2` is a subtype of
the type of `e1`.

The type of the entire expression is the type of `e2` if `e1` is a subtype of
`e2` and the type of `e1` if `e2` is a subtype of `e1`.

Conditional expressions are evaluated by first evaluating `e0`.  Then, the
value of that expression determines which of the other subexpressions is
evaluated:

- if the value of `e0` is `true`, then `e1` is evaluated and its value is the
  value of the entire expression
- if the value of `e0` is `false`, then `e2` is evaluated and its value is the
  value of the entire expression

The evaluation rules ensure that only one of `e1` and `e2` is evaluated.

#### Map and fold expressions

Compact supports expressions that perform the higher-order operations _map_ and
(left) _fold_ over tuples that have a vector type (not arbitrary tuples).

Map expressions have the form `map(f, e, e, ...)` where `map` is a keyword, `f`
is a circuit or witness taking at least one argument, and the `e`s are
expressions.  A circuit or witness taking _n_ arguments can be mapped over _n_
argument vectors by providing _n_ vector subexpressions to the `map`.

Fold expressions have the form `fold(f, init, e, e, ...)` where `fold` is a
keyword, `f` is a circuit or witness, and `init` and the `e`s are expressions.
A circuit or witness taking _n_+1 arguments can be folded over an initial value
`init` and _n_ vectors by providing _n_ vector subexpressions to the `fold`.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>map</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<b><tt>fold</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

The syntax of the circuit or witness is given by the grammar production for
_fun_ in the section **Circuit and witness calls** above.

A map expression is type checked by checking the type of the witness or circuit
`f` to find its parameter types and its return type `R`.  `f` must have at least
one parameter.  The map expression must have the same number of vector subexpressions
as the number of parameters of `f`.  Each of the vector subexpressions
must have a vector type and all these vector types must have the same length
`n`.  If the type of the *i*th parameter to `f` is `T`, then the type of the
*i*th vector subexpression must be `Vector<n, S>` where `S` is a subtype of
`T`.  The type of entire expression is `Vector<n, R>`.

A fold expression is type checked by checking the type of the witness or circuit
`f` to find its parameter types and its return type `R`.  `f` must have at least
two parameters, and the type of the first parameter must be the same type as the
return type `R`.  The fold expression must have one fewer vector subexpression
than the number of parameters of `f`.  The subexpression `e` gives the initial
value for the fold.  It must have a type which is a subtype `R`.  Each of the
vector subexpressions must have a vector type and all these vector types must
have the same length `n`.  If the type of the *i*+1th parameter of `f` is `T`
then the type of the *i*th vector subexpression must be `Vector<n, S>` where `S`
is a subtype of `T`.  The type of the entire expression is `R`.

Map expressions are evaluated by evaluating the vector subexpressions from left
to right.  These values are the input vector values.  The witness or circuit `f`
is then applied in turn, from index 0 up to index `n`-1, to arguments taken from
the input vector values.  The result is a vector of length `n` where each *i*th
element is the result of applying `f` to the *i*th element of the corresponding
input vector values.

Fold expressions are evaluated by evaluating the initial value expression `e`
and then evaluating the vector subexpressions from left to right.  The values of
the vector expressions are the input vector values.  The witness or circuit `f`
is then applied in turn, from index 0 up to index `n`-1, to an accumulator value
argument and arguments taken from the input vector values.  The 0th (initial)
accumulator value is the value of the expression `e`, and each subsequent
*i*+1th accumulator value is the result of applying `f` to the *i*th accumulator
value and to the *i*th element of the corresponding input vector values.  The
result is the `n`th (final) accumulator value where `n` is the length of the
input vectors.

#### Ledger assignment expressions

Compact has ledger assignment statements.  They have the form `lhs op e` where
`lhs` is a ledger expression as defined in the section **Ledger expressions**
above, `op` is one of the assignment operators `=` (assignment), `+=` (addition
assignment), or `-=` (subtraction assignment), and `e` is an expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>+=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>-=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

`lhs = e` is shorthand for `lhs.write(e)`.  `lhs += e` is shorthand for
`lhs.increment(e)`.  `lhs -= e` is shorthand for `lhs.decrement(e)`.

Ledger assignment statements are type checked exactly as if they were their
longer equivalent invoking a ledger ADT operation.

They are evaluated exactly as if their longer equivalent were evaluated as a
ledger expression.
