import {
    contractDependencies,
    ContractId,
    ContractReferenceLocationsSet,
    ContractAddress,
    StateValue,
    ContractDependency,
    CompactError
} from '@midnight-ntwrk/compact-runtime';

/**
 * To execute a contract that contains inter-contract calls, Midnight.js needs a way to get the states of all contracts
 * that a contract calls. Contracts may be composed at arbitrary depths, but contract dependencies cannot form cycles,
 * so they always form a tree. Midnight.js can assume that the compiler, for each contract, generates a data structure
 * that indicates where all the contract references are in that contracts ledger state, as well as where the contract
 * references are in all of its dependencies ledger states. That's what `referenceLocationsSet` is.
 *
 * The `compact-runtime` package will expose a function `contractDependencies` that extracts the contract dependencies
 * for a single contract. Given `contractDependencies`, `referenceLocationsSet` produced by the compiler, the contract
 * ID of the contract being called (generated as `contractId` by the compiler), the address of the contract being called,
 * and a state fetcher `stateProvider`, the following function does a breadth first search on the ledger states of the
 * root contract and returns all of its dependencies ledger states. Note that `stateProvider` could also return an object
 * containing the public, private, and Zswap local states of the contract so that the result of `recursiveContractDependencies`
 * is a mapping from contract addresses to ALL the states needed to execute a circuit for that contract.
 *
 * @param referenceLocationsSet The reference location object generated by the compiler.
 * @param rootContractId The `contractId` of the root contract being called.
 * @param rootAddress The address of the root contract being called.
 * @param currentLedgerStates The current ledger states for the contracts (simulates current chain state)
 */
export const resolveContractDependencies = (
    referenceLocationsSet: ContractReferenceLocationsSet,
    rootContractId: ContractId,
    rootAddress: ContractAddress,
    currentLedgerStates: Record<ContractAddress, StateValue>
): Record<ContractAddress, StateValue> => {

    const result: Record<ContractAddress, StateValue> = {};
    const visited = new Set<ContractAddress>();
    const queue: ContractDependency[] = [{contractId: rootContractId, address: rootAddress}];

    while (queue.length > 0) {
        const current = queue.shift()!;
        if (visited.has(current.address)) {
            continue;
        }
        visited.add(current.address);
        const currentState = currentLedgerStates[current.address];
        if (!currentState) {
            throw new CompactError(`resolution error: no contract state found for contract '${current.contractId}' at address '${current.address}'`);
        }
        result[current.address] = currentState;
        const referenceLocations = referenceLocationsSet[current.contractId];
        if (!referenceLocations) {
            throw new CompactError(`resolution error: no contract reference location descriptor found for contract '${current.contractId}' at address '${current.address}'`);
        }
        const dependencies = contractDependencies(referenceLocations, currentState);
        for (const dependency of dependencies) {
            if (!visited.has(dependency.address)) {
                queue.push(dependency);
            }
        }
    }

    return result;
}